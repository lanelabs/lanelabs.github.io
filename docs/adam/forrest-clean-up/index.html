<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Forrest Clean Up</title>
  <style>
    :root {
      --bg-top: #d9f4d4;
      --bg-mid: #bde6bb;
      --bg-bottom: #89c98c;
      --panel: #f8fff6;
      --ink: #1d3a24;
      --accent: #2f8f4a;
      --line: #cfe9c9;
      --shadow: 0 10px 28px rgba(21, 57, 28, 0.18);
      --radius: 14px;
      --play-ui-scale: 1;
    }

    /* Runtime JS sets --play-ui-scale from canvas size for smooth resize behavior. */

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Trebuchet MS", "Verdana", sans-serif;
      color: var(--ink);
      min-height: 100vh;
      background: linear-gradient(180deg, var(--bg-top), var(--bg-mid) 40%, var(--bg-bottom));
      display: grid;
      place-items: center;
      padding: 18px;
    }

    .shell {
      width: min(1720px, 100%);
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .game-wrap {
      padding: 0;
      position: relative;
      border: none;
      box-shadow: none;
      background: transparent;
      overflow: hidden;
      border-radius: 0;
    }

    .game-stage {
      position: relative;
      overflow: hidden;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 30px;
      line-height: 1;
      color: #1a4f2d;
      letter-spacing: 0.3px;
    }

    .subtitle {
      margin: 0 0 10px;
      font-size: 14px;
      color: #356a45;
    }

    canvas {
      display: block;
      width: 100%;
      height: auto;
      border-radius: 0;
      border: 0;
      background: #8fbf7d;
      touch-action: none;
      position: relative;
      z-index: 1;
    }

    .ui {
      padding: 14px;
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 10px;
      font-size: 14px;
    }

    .label { font-weight: 700; }

    .value {
      background: #eef8eb;
      border: 1px solid #d1ebcc;
      border-radius: 999px;
      padding: 4px 9px;
      min-width: 42px;
      text-align: center;
      font-weight: 700;
    }

    .msg {
      min-height: 92px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      font-size: 14px;
      line-height: 1.4;
    }

    .btns {
      display: grid;
      gap: 8px;
    }

    button {
      border: 1px solid #2f8f4a;
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      padding: 10px;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
    }

    button:hover { filter: brightness(1.06); }
    button.secondary {
      background: #fff;
      color: #266f3b;
      border-color: #8ec597;
    }

    .tips {
      border: 1px dashed #99cca4;
      border-radius: 10px;
      padding: 10px;
      background: #f7fff5;
      font-size: 13px;
      line-height: 1.45;
    }

    .tips-toggle {
      margin-top: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: #2b5f3d;
    }

    .tips-toggle button {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
      background: #fff;
      color: #266f3b;
      border: 1px solid #8ec597;
    }

    .inspect {
      border: 1px solid #c7e4c8;
      border-radius: 10px;
      padding: 10px;
      background: #ffffff;
      font-size: 13px;
      line-height: 1.42;
    }

    .inspect-title {
      margin: 0 0 8px;
      font-size: 14px;
      font-weight: 700;
      color: #1e5d35;
    }

    .inspect-line {
      margin: 4px 0;
    }

    .campsite {
      border: 1px solid #c7e4c8;
      border-radius: 10px;
      padding: 10px;
      background: #ffffff;
      display: grid;
      gap: 8px;
    }

    .campsite-title {
      margin: 0;
      font-size: 14px;
      font-weight: 700;
      color: #1e5d35;
    }

    .campsite-note {
      font-size: 12px;
      color: #355c43;
    }

    .campsite-list {
      display: grid;
      gap: 8px;
    }

    .campsite-item {
      border: 1px solid #cfe3d0;
      border-radius: 10px;
      padding: 8px 10px;
      background: #f7fff5;
      text-align: left;
      cursor: pointer;
      display: grid;
      gap: 3px;
      font-size: 13px;
      color: #1f4d30;
    }

    .campsite-item:hover {
      border-color: #7db78a;
      background: #eef9ec;
    }

    .campsite-item:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      background: #f2f7f1;
    }

    .campsite-item strong {
      font-size: 13px;
    }

    .campsite-mode {
      font-size: 12px;
      color: #2b6c3f;
      font-weight: 700;
      padding: 6px 8px;
      border-radius: 8px;
      background: #f1fbf0;
      border: 1px dashed #9fcea8;
    }

    .profile {
      border: 1px solid #c7e4c8;
      border-radius: 10px;
      padding: 10px;
      background: #ffffff;
      display: grid;
      gap: 8px;
    }

    .profile-title {
      margin: 0;
      font-size: 14px;
      font-weight: 700;
      color: #1e5d35;
    }

    .profile-input {
      border: 1px solid #cfe3d0;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      color: #1f4d30;
      background: #f7fff5;
    }

    .profile-note {
      font-size: 12px;
      color: #355c43;
    }

    .quests {
      border: 1px solid #c7e4c8;
      border-radius: 10px;
      padding: 10px;
      background: #ffffff;
      display: grid;
      gap: 8px;
    }

    .quests-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .quests-title {
      margin: 0;
      font-size: 14px;
      font-weight: 700;
      color: #1e5d35;
    }

    .quest-toggle {
      border: 1px solid #8ec597;
      background: #ffffff;
      color: #266f3b;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
    }

    .quest-toggle:hover {
      background: #f1fbf0;
    }

    .quest-list {
      display: grid;
      gap: 4px;
      max-height: 140px;
      overflow: auto;
    }

    .quest-collapsed-note {
      display: none !important;
      font-size: 12px;
      color: #355c43;
    }

    .quests.expanded .quest-list {
      max-height: none;
    }

    .quest-toggle {
      min-width: 60px;
    }

    .quest-item {
      border: 0;
      border-radius: 0;
      padding: 0;
      background: transparent;
      text-align: left;
      cursor: default;
      display: block;
      font-size: 12px;
      color: #244f34;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .quest-item:hover {
      color: #244f34;
    }

    .quest-item.done {
      color: #93a79a;
    }

    .quest-head {
      display: inline;
      font-weight: 400;
    }

    .quest-tag {
      display: none;
    }

    .quest-progress {
      display: none;
    }

    .quest-note {
      display: inline;
      font-size: 12px;
      color: inherit;
    }

    .quest-popup {
      position: fixed;
      inset: 0;
      background: rgba(8, 20, 12, 0.58);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 60;
    }

    .quest-popup.open {
      display: flex;
    }

    .quest-panel {
      width: min(520px, 100%);
      background: #f8fff6;
      border: 1px solid #b8d8b6;
      border-radius: 12px;
      box-shadow: 0 16px 42px rgba(0, 0, 0, 0.28);
      padding: 14px;
      display: grid;
      gap: 10px;
    }

    .quest-panel h2 {
      margin: 0;
      font-size: 18px;
      color: #1f5f37;
    }

    .quest-panel p {
      margin: 0;
      font-size: 14px;
      line-height: 1.5;
      color: #2b5540;
    }

    .quest-panel .quest-progress {
      font-size: 13px;
    }

    .debug-overlay {
      position: fixed;
      inset: 0;
      background: rgba(8, 20, 12, 0.58);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 80;
    }

    .debug-overlay.open {
      display: flex;
    }

    .debug-panel {
      width: min(980px, 100%);
      max-height: 88vh;
      overflow: auto;
      background: #f8fff6;
      border: 1px solid #b8d8b6;
      border-radius: 12px;
      box-shadow: 0 16px 42px rgba(0, 0, 0, 0.28);
      padding: 14px;
    }

    .debug-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
    }

    .debug-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
    }

    .debug-controls button {
      border: 1px solid #8ec597;
      background: #ffffff;
      color: #215e36;
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
    }

    .debug-slider {
      display: grid;
      gap: 6px;
      padding: 8px;
      border: 1px dashed #c8e1c7;
      border-radius: 10px;
      background: #f7fff6;
      font-size: 12px;
      color: #2b5540;
      min-width: 220px;
    }

    .debug-slider input[type="range"] {
      width: 100%;
    }

    .sprite-sample {
      border: 1px solid #c8e1c7;
      border-radius: 10px;
      background: #ffffff;
      padding: 10px;
      display: grid;
      gap: 6px;
    }

    .sprite-sample canvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      border: 1px dashed #c8e1c7;
      background: #f3fbf2;
    }

    .debug-title {
      margin: 0;
      font-size: 18px;
      color: #1f5f37;
    }

    .debug-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .debug-box {
      border: 1px solid #c8e1c7;
      border-radius: 10px;
      background: #ffffff;
      padding: 10px;
      font-size: 13px;
      line-height: 1.45;
    }

    .debug-box h3 {
      margin: 0 0 6px;
      font-size: 14px;
      color: #205f37;
    }

    .debug-pre {
      margin: 0;
      white-space: pre-wrap;
      font-family: "Consolas", "Menlo", monospace;
      font-size: 12px;
      color: #224830;
    }

    @media (max-width: 900px) {
      .debug-grid {
        grid-template-columns: 1fr;
      }
    }

    .foot {
      margin-top: 4px;
      font-size: 12px;
      color: #2d6640;
      text-align: center;
    }

    .floating-message {
      position: absolute;
      right: 12px;
      top: 62px;
      width: clamp(120px, 45vw, 420px);
      z-index: 18;
      transform: scale(var(--play-ui-scale));
      transform-origin: top right;
      --msg-toggle-space: 28px;
      --msg-rgb: 26, 56, 36;
      --msg-shadow-dark-a: 0.56;
      --msg-shadow-light-a: 0.4;
      --msg-outline-a: 0.44;
    }

    .msg-head {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
    }

    .msg-inline {
      margin: 0;
      font-size: calc(11px * var(--play-ui-scale));
      color: rgb(var(--msg-rgb));
      line-height: 1.4;
      min-height: 18px;
      text-align: right;
      text-shadow:
        0 1px 0 rgba(0, 0, 0, var(--msg-shadow-dark-a)),
        0 -1px 0 rgba(255, 255, 255, var(--msg-shadow-light-a)),
        0 0 3px rgba(0, 0, 0, var(--msg-outline-a));
    }

    .msg-toggle {
      border: 0;
      background: transparent;
      color: rgb(var(--msg-rgb));
      border-radius: 999px;
      min-width: calc(28px * var(--play-ui-scale));
      height: calc(18px * var(--play-ui-scale));
      padding: 0;
      font-size: calc(11px * var(--play-ui-scale));
      line-height: 1.2;
      text-transform: lowercase;
      text-shadow:
        0 1px 0 rgba(0, 0, 0, var(--msg-shadow-dark-a)),
        0 -1px 0 rgba(255, 255, 255, var(--msg-shadow-light-a)),
        0 0 3px rgba(0, 0, 0, var(--msg-outline-a));
    }

    .msg-history {
      padding: 2px var(--msg-toggle-space) 0 0;
      font-size: calc(11px * var(--play-ui-scale));
      color: rgb(var(--msg-rgb));
      line-height: 1.4;
      white-space: pre-wrap;
      text-shadow:
        0 1px 0 rgba(0, 0, 0, var(--msg-shadow-dark-a)),
        0 -1px 0 rgba(255, 255, 255, var(--msg-shadow-light-a)),
        0 0 3px rgba(0, 0, 0, var(--msg-outline-a));
      text-align: right;
    }

    .msg-history[hidden] {
      display: none;
    }

    .top-stats-hud {
      display: none;
    }

    .top-stat {
      border: 1px solid rgba(176, 210, 176, 0.9);
      border-radius: 999px;
      background: rgba(248, 255, 246, 0.9);
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 700;
      color: #255e39;
      white-space: nowrap;
      box-shadow: 0 6px 12px rgba(20, 55, 33, 0.18);
    }

    .quest-widget {
      position: absolute;
      top: 12px;
      left: 12px;
      width: clamp(120px, 45vw, 320px);
      padding: 0;
      z-index: 18;
      display: grid;
      gap: 6px;
      transform: scale(var(--play-ui-scale));
      transform-origin: top left;
      --msg-rgb: 26, 56, 36;
      --msg-shadow-dark-a: 0.56;
      --msg-shadow-light-a: 0.4;
      --msg-outline-a: 0.44;
    }

    .quest-widget-head {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 6px;
    }

    .quest-widget-title {
      margin: 0;
      font-size: calc(12px * var(--play-ui-scale));
      font-weight: 700;
      color: rgb(var(--msg-rgb));
      text-shadow:
        0 1px 0 rgba(0, 0, 0, var(--msg-shadow-dark-a)),
        0 -1px 0 rgba(255, 255, 255, var(--msg-shadow-light-a)),
        0 0 3px rgba(0, 0, 0, var(--msg-outline-a));
    }

    .quest-widget-toggle {
      border: 0;
      background: transparent;
      color: rgb(var(--msg-rgb));
      border-radius: 999px;
      width: calc(18px * var(--play-ui-scale));
      height: calc(18px * var(--play-ui-scale));
      padding: 0;
      font-size: calc(11px * var(--play-ui-scale));
      font-weight: 700;
      cursor: pointer;
      text-shadow:
        0 1px 0 rgba(0, 0, 0, var(--msg-shadow-dark-a)),
        0 -1px 0 rgba(255, 255, 255, var(--msg-shadow-light-a)),
        0 0 3px rgba(0, 0, 0, var(--msg-outline-a));
    }

    .quest-widget-list {
      display: grid;
      gap: 3px;
    }

    .quest-widget-item {
      border: 0;
      border-radius: 0;
      padding: 0;
      font-size: calc(10px * var(--play-ui-scale));
      line-height: 1.4;
      font-weight: 400;
      background: transparent;
      color: rgb(var(--msg-rgb));
      text-align: left;
      cursor: default;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow:
        0 1px 0 rgba(0, 0, 0, var(--msg-shadow-dark-a)),
        0 -1px 0 rgba(255, 255, 255, var(--msg-shadow-light-a)),
        0 0 3px rgba(0, 0, 0, var(--msg-outline-a));
    }

    .quest-widget-item.done {
      color: rgb(var(--msg-rgb));
    }

    .quest-widget-progress {
      display: none;
    }

    .quest-widget-more {
      border: 0;
      background: transparent;
      padding: 0;
      margin-top: 1px;
      font-size: calc(11px * var(--play-ui-scale));
      line-height: 1;
      color: rgb(var(--msg-rgb));
      text-align: left;
      cursor: default;
      text-shadow:
        0 1px 0 rgba(0, 0, 0, var(--msg-shadow-dark-a)),
        0 -1px 0 rgba(255, 255, 255, var(--msg-shadow-light-a)),
        0 0 3px rgba(0, 0, 0, var(--msg-outline-a));
    }

    .notebook-panel {
      --notebook-line: 24px;
      position: absolute;
      left: 18%;
      bottom: -2px;
      transform: translateX(-50%) translateY(calc(100% - var(--notebook-line)));
      transform-origin: bottom center;
      width: min(350px, calc(100% - 24px));
      border: 1px solid #cfbf9f;
      border-radius: 10px 10px 0 0;
      background:
        repeating-linear-gradient(
          to bottom,
          #f8f2df 0px,
          #f8f2df calc(var(--notebook-line) - 1px),
          rgba(90, 120, 175, 0.22) calc(var(--notebook-line) - 1px),
          rgba(90, 120, 175, 0.22) var(--notebook-line)
        );
      box-shadow: 0 -8px 18px rgba(18, 49, 29, 0.24);
      z-index: 2;
      transition: transform 220ms ease, opacity 180ms ease;
      opacity: 1;
      pointer-events: auto;
    }

    .notebook-panel.peek {
      transform: translateX(-50%) translateY(calc(100% - (var(--notebook-line) * 2.7)));
    }

    .notebook-panel.collapsed {
      transform: translateX(-50%) translateY(calc(100% - var(--notebook-line)));
    }

    .notebook-panel.expanded {
      transform: translateX(-50%) translateY(0);
    }

    .notebook-tab {
      width: 100%;
      border: 0;
      background: transparent;
      color: #3e4a37;
      text-align: left;
      padding: 0 10px;
      min-height: var(--notebook-line);
      line-height: var(--notebook-line);
      font-size: 13px;
      font-weight: 700;
      display: flex;
      flex-wrap: nowrap;
      justify-content: space-between;
      align-items: center;
      cursor: default;
      white-space: nowrap;
      gap: 6px;
    }

    .notebook-tab-label,
    .notebook-tab-arrow-hit {
      cursor: pointer;
    }

    .notebook-tab-label,
    .notebook-tab-mid,
    .notebook-tab-arrow-hit {
      flex: 0 0 auto;
    }

    .notebook-tab-mid {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      font-weight: 700;
      line-height: 1;
      color: #4a5642;
    }

    .notebook-page-btn {
      border: 0;
      background: transparent;
      color: #3e4a37;
      padding: 0;
      font-size: 24px;
      min-width: 26px;
      line-height: 1;
      cursor: pointer;
    }

    .notebook-page-btn:disabled {
      opacity: 0.35;
      cursor: default;
    }

    .notebook-page-count {
      min-width: 36px;
      text-align: center;
      letter-spacing: 0.15px;
    }

    #notebookTabArrow {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      line-height: 1;
      min-width: 24px;
    }

    .notebook-tab.hint-pulse #notebookTabArrow {
      animation: notebookArrowPulse 680ms ease-in-out infinite;
    }

    @keyframes notebookArrowPulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.28);
        opacity: 0.42;
      }
    }

    .notebook-head {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
      padding: 0 10px;
      font-size: 13px;
      line-height: var(--notebook-line);
      color: #3e4a37;
      min-height: var(--notebook-line);
    }

    .notebook-type {
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .notebook-body {
      display: none;
      padding: 0 10px 8px;
      font-size: 13px;
      color: #334032;
      line-height: var(--notebook-line);
      gap: 0;
    }

    .notebook-body .inspect-line {
      margin: 0;
      min-height: var(--notebook-line);
      line-height: var(--notebook-line);
    }

    .inspect-observations {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 2px;
      font-size: 12px;
      line-height: 1.35;
      color: #334032;
    }

    .inspect-observations li {
      margin: 0;
    }

    .inspect-observations-typing {
      margin: 2px 0 0;
      min-height: 16px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .inspect-observations-typing span {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: rgba(66, 78, 63, 0.55);
      animation: notebookTypingDots 950ms ease-in-out infinite;
    }

    .inspect-observations-typing span:nth-child(2) {
      animation-delay: 120ms;
    }

    .inspect-observations-typing span:nth-child(3) {
      animation-delay: 240ms;
    }

    @keyframes notebookTypingDots {
      0%, 70%, 100% {
        transform: translateY(0);
        opacity: 0.35;
      }
      35% {
        transform: translateY(-2px);
        opacity: 1;
      }
    }

    .inspect-observations-empty {
      margin: 0;
      font-size: 12px;
      line-height: 1.35;
      color: #66725f;
      font-style: italic;
      min-height: calc(var(--notebook-line) * 1.1);
    }

    .obs-badge {
      display: inline-block;
      margin-left: 6px;
      padding: 0 6px;
      border-radius: 999px;
      font-size: 10px;
      line-height: 15px;
      color: #2d6140;
      background: rgba(162, 220, 175, 0.55);
      border: 1px solid rgba(72, 133, 88, 0.35);
      vertical-align: middle;
    }

    .notebook-body .profile-input {
      height: 20px;
      padding: 0 6px;
      border-radius: 6px;
      font-size: 12px;
      vertical-align: middle;
    }

    .notebook-panel.expanded .notebook-body {
      display: grid;
      max-height: none;
      overflow: visible;
    }

    .notebook-panel.peek .notebook-body {
      display: grid;
      max-height: calc(var(--notebook-line) * 0.5);
      overflow: hidden;
      padding-bottom: 0;
    }

    .notebook-empty {
      display: none;
      margin: 0;
      padding: 4px 10px 10px;
      font-size: 13px;
      line-height: 1.5;
      color: #3e4a37;
    }

    .notebook-panel:not(.has-selection) .notebook-head,
    .notebook-panel:not(.has-selection) .notebook-body {
      display: none;
    }

    .notebook-panel:not(.has-selection).expanded .notebook-empty {
      display: block;
    }

    .build-fab {
      position: absolute;
      right: 12px;
      bottom: 12px;
      width: calc(42px * var(--play-ui-scale));
      height: calc(42px * var(--play-ui-scale));
      border-radius: 999px;
      border: 2px solid #2f8f4a;
      font-size: calc(18px * var(--play-ui-scale));
      padding: 0;
      z-index: 19;
      box-shadow: 0 10px 18px rgba(26, 63, 38, 0.24);
    }

    .build-popup {
      position: absolute;
      right: 12px;
      bottom: 60px;
      width: min(300px, calc(100% - 24px));
      border: 1px solid #bfdcbc;
      border-radius: 10px;
      background: rgba(248, 255, 246, 0.97);
      box-shadow: 0 10px 22px rgba(20, 50, 31, 0.24);
      padding: 10px;
      display: grid;
      gap: 8px;
      z-index: 19;
    }

    .build-popup[hidden] {
      display: none;
    }

    .inventory-bar {
      margin-top: 10px;
      border: 1px solid #bfdcbc;
      border-radius: 10px;
      background: #f7fff5;
      padding: 8px;
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
    }

    .inv-slot {
      border: 1px solid #d2e7cf;
      border-radius: 10px;
      background: #ffffff;
      min-height: 58px;
      display: grid;
      place-items: center;
      padding: 4px;
      text-align: center;
      gap: 2px;
    }

    .inv-slot.trash-slot {
      align-items: center;
      justify-items: center;
      padding: 6px 6px;
    }

    .inv-glyph {
      position: relative;
      width: 20px;
      height: 20px;
      margin-top: 2px;
    }

    .inv-glyph.acorn::before {
      content: "";
      position: absolute;
      left: 4px;
      top: 4px;
      width: 12px;
      height: 13px;
      border-radius: 65% 65% 58% 58%;
      background: #b07a45;
      border: 1px solid #7a5632;
    }

    .inv-glyph.acorn::after {
      content: "";
      position: absolute;
      left: 4px;
      top: 2px;
      width: 12px;
      height: 3px;
      border-radius: 2px;
      background: #8a5a2c;
    }

    .inv-glyph.water::before {
      content: "";
      position: absolute;
      left: 6px;
      top: 2px;
      width: 8px;
      height: 14px;
      border-radius: 55% 55% 60% 60%;
      transform: rotate(10deg);
      background: transparent;
      border: 1.4px solid #4a95ad;
      box-sizing: border-box;
    }

    .inv-glyph.water.full::before {
      background: #7ec7df;
    }

    .inv-glyph.sapling::before {
      content: "";
      position: absolute;
      left: 9px;
      top: 7px;
      width: 2px;
      height: 10px;
      background: #7a5632;
    }

    .inv-glyph.sapling::after {
      content: "";
      position: absolute;
      left: 5px;
      top: 3px;
      width: 10px;
      height: 8px;
      border-radius: 60% 55% 45% 60%;
      background: #6f9a71;
      border: 1px solid #567c59;
      transform: rotate(-10deg);
    }

    .inv-glyph.litter::before {
      content: "";
      position: absolute;
      left: 3px;
      top: 6px;
      width: 14px;
      height: 10px;
      background: #f7d36f;
      border: 1px solid rgba(80, 70, 55, 0.65);
      transform: rotate(-10deg);
    }

    .inv-glyph.litter::after {
      content: "";
      position: absolute;
      left: 7px;
      top: 4px;
      width: 10px;
      height: 7px;
      background: #56c2ff;
      border: 1px solid rgba(80, 70, 55, 0.65);
      transform: rotate(14deg);
    }

    .gather-placeholder {
      font-size: 11px;
      color: #8ca39a;
      font-style: italic;
      margin-top: 2px;
    }

    .trash-stack {
      position: relative;
      height: 14px;
      width: 100%;
      max-width: 88px;
    }

    .trash-chip {
      position: absolute;
      top: 2px;
      width: 8px;
      height: 6px;
      border: 1px solid rgba(80, 70, 55, 0.7);
      transform-origin: 50% 50%;
      border-radius: 1px;
    }

    .inv-glyph.best::before {
      content: "";
      position: absolute;
      left: 4px;
      top: 4px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #f6d77b;
      border: 1px solid #b59045;
    }

    .inv-glyph.best::after {
      content: "";
      position: absolute;
      left: 8px;
      top: 8px;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #c79f52;
    }

    .inv-count {
      font-size: 12px;
      font-weight: 700;
      color: #245f37;
    }

    .acorn-stack {
      position: relative;
      height: 16px;
      width: 100%;
      max-width: 72px;
      margin-top: 1px;
    }

    .acorn-chip {
      position: absolute;
      top: 1px;
      width: 11px;
      height: 14px;
      border-radius: 58% 58% 62% 62%;
      background: #b07a45;
      border: 1px solid #7a5632;
      transform-origin: 50% 75%;
    }

    .acorn-chip::before {
      content: "";
      position: absolute;
      left: -1px;
      top: -3px;
      width: 11px;
      height: 3px;
      background: #8a5a2c;
      border-radius: 2px;
    }

    .below-grid {
      margin-top: 10px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .touch-controls {
      display: none;
      justify-content: space-between;
      align-items: flex-end;
      gap: 16px;
      margin-top: 10px;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    .touch-controls.is-hidden {
      display: none !important;
    }

    .joystick {
      width: 132px;
      height: 132px;
      border-radius: 50%;
      border: 2px solid #6da37a;
      background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.65), rgba(102, 154, 112, 0.32));
      position: relative;
      touch-action: none;
    }

    .joystick-knob {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 2px solid #3f8350;
      background: #f4fff2;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 12px rgba(28, 70, 39, 0.22);
      touch-action: none;
    }

    .touch-action {
      min-width: 118px;
      height: 66px;
      border-radius: 14px;
      border: 2px solid #2f8f4a;
      background: #2f8f4a;
      color: #fff;
      font-weight: 800;
      font-size: 16px;
      box-shadow: 0 8px 16px rgba(37, 95, 52, 0.24);
      touch-action: manipulation;
    }

    .touch-action.active {
      filter: brightness(0.92);
      transform: translateY(1px);
    }

    .menu-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: calc(84px * var(--play-ui-scale));
      height: calc(42px * var(--play-ui-scale));
      border-radius: 999px;
      border: 2px solid #2f8f4a;
      background: rgba(248, 255, 246, 0.95);
      color: #215e36;
      font-weight: 800;
      font-size: calc(14px * var(--play-ui-scale));
      box-shadow: 0 8px 18px rgba(14, 41, 23, 0.24);
      touch-action: manipulation;
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 19;
      transform: scale(var(--play-ui-scale));
      transform-origin: top right;
    }

    .menu-panel {
      position: fixed;
      inset: 0;
      background: rgba(8, 20, 12, 0.58);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 68;
    }

    .menu-panel[hidden] {
      display: none;
    }

    .menu-sheet {
      position: relative;
      width: min(560px, 100%);
      max-height: 88vh;
      overflow: auto;
      border: 1px solid #bfdcbc;
      border-radius: 10px;
      background: rgba(248, 255, 246, 0.98);
      box-shadow: 0 10px 22px rgba(20, 50, 31, 0.24);
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .menu-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid #8ec597;
      background: #ffffff;
      color: #266f3b;
      font-size: 16px;
      line-height: 1;
      padding: 0;
      cursor: pointer;
    }

    .menu-label {
      font-size: 12px;
      color: #2f5f3f;
      display: grid;
      gap: 4px;
    }

    .start-overlay {
      position: fixed;
      inset: 0;
      background: rgba(8, 20, 12, 0.58);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 70;
    }

    .start-overlay.open {
      display: flex;
    }

    .start-panel {
      width: min(520px, 100%);
      background: #f8fff6;
      border: 1px solid #b8d8b6;
      border-radius: 12px;
      box-shadow: 0 16px 42px rgba(0, 0, 0, 0.28);
      padding: 14px;
      display: grid;
      gap: 10px;
    }

    .start-panel h2 {
      margin: 0;
      font-size: 24px;
      color: #1f5f37;
    }

    .start-panel p {
      margin: 0;
      font-size: 14px;
      line-height: 1.5;
      color: #2b5540;
    }

    .ui-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(10, 28, 15, 0.38);
      display: none;
      z-index: 34;
    }

    .ui-backdrop.open {
      display: block;
    }

    @media (max-width: 900px) {
      h1 { font-size: 25px; }
      .below-grid { grid-template-columns: 1fr; }
      .inventory-bar { grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .floating-message { width: calc(100% - 24px); }
      .floating-message { top: 62px; }
    }

    @media (hover: none), (pointer: coarse) {
      body {
        display: block;
        padding: 0;
        min-height: 100dvh;
      }

      .shell {
        width: 100vw;
        height: 100dvh;
        display: block;
      }

      .card {
        border: none;
        border-radius: 0;
        box-shadow: none;
        background: transparent;
      }

      .game-wrap {
        width: 100vw;
        height: 100dvh;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      h1,
      .subtitle,
      .foot {
        display: none;
      }

      canvas {
        width: 100%;
        height: 100%;
        border: 0;
        border-radius: 0;
      }

      .touch-controls {
        display: flex;
        position: absolute;
        left: 12px;
        right: 12px;
        bottom: calc(10px + env(safe-area-inset-bottom));
        margin-top: 0;
        z-index: 22;
        pointer-events: none;
      }

      .joystick,
      .touch-action {
        pointer-events: auto;
      }

      .menu-toggle {
        top: calc(10px + env(safe-area-inset-top));
        z-index: 36;
      }

      .floating-message {
        top: calc(58px + env(safe-area-inset-top));
      }

      .menu-panel {
        padding-top: calc(12px + env(safe-area-inset-top));
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
      }

      .build-fab {
        bottom: calc(96px + env(safe-area-inset-bottom));
      }

      .build-popup {
        bottom: calc(146px + env(safe-area-inset-bottom));
      }

      .top-stats-hud {
        top: calc(58px + env(safe-area-inset-top));
      }

      .quest-widget {
        top: calc(10px + env(safe-area-inset-top));
      }

      .ui {
        position: fixed;
        top: calc(60px + env(safe-area-inset-top));
        left: 10px;
        right: 10px;
        bottom: calc(10px + env(safe-area-inset-bottom));
        z-index: 35;
        display: none;
        background: var(--panel);
        overflow: auto;
        border: 1px solid #b8d7ba;
        border-radius: 14px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.28);
      }

      .ui.open {
        display: grid;
      }
    }
  </style>
</head>
<body>
  <main class="shell">
    <section class="card game-wrap">
      <div class="game-stage">
        <canvas id="game" width="1600" height="920" aria-label="Forrest Clean Up game"></canvas>
        <button id="menuToggle" class="menu-toggle" type="button" aria-label="Open game menu" aria-expanded="false">Menu</button>
        <div id="gameMenu" class="menu-panel" hidden>
          <div class="menu-sheet">
            <button id="menuClose" class="menu-close" type="button" aria-label="Close menu">Ã—</button>
            <label class="menu-label">
              Ranger Name
              <input id="menuPlayerName" class="profile-input" type="text" maxlength="22" placeholder="name (optional)" aria-label="Ranger name">
            </label>
            <div class="inventory-bar">
              <div class="inv-slot" title="Acorns">
                <div id="acornStack" class="acorn-stack"></div>
                <div id="acornPlaceholder" class="gather-placeholder">acorns gathered</div>
              </div>
              <div class="inv-slot" title="Water">
                <div id="waterIcon" class="inv-glyph water" aria-hidden="true"></div>
                <div id="water" class="inv-count">Empty</div>
              </div>
              <div class="inv-slot" title="Trees Planted">
                <div class="inv-glyph sapling" aria-hidden="true"></div>
                <div id="trees" class="inv-count">0</div>
              </div>
              <div class="inv-slot trash-slot" title="Litter Cleaned">
                <div id="cleanedStack" class="trash-stack" aria-label="Trash collected: 0"></div>
                <div id="cleanedPlaceholder" class="gather-placeholder">litter cleaned</div>
              </div>
              <div class="inv-slot" title="Best Score">
                <div class="inv-glyph best" aria-hidden="true"></div>
                <div id="best" class="inv-count">0</div>
              </div>
            </div>
            <div class="tips">
              Controls: WASD/arrow keys to move, Space to interact, or use on-screen joystick + Interact on touch screens.<br>
              Start by cleaning nearby litter, collecting acorns, and planting trees in open spots.<br>
              Keep helping the forest and watch how the world responds over time.
              <div class="tips-toggle">
                <span id="touchModeLabel">Touch Controls: On</span>
                <button id="touchModeToggle" type="button">Hide Touch UI</button>
              </div>
            </div>
            <div class="quests" id="questPanel">
              <div class="quests-head">
                <p class="quests-title">Quest Log</p>
                <button id="questToggle" class="quest-toggle" type="button" aria-expanded="true">Hide</button>
              </div>
              <div id="questList" class="quest-list" aria-live="polite"></div>
              <div id="questCollapsedNote" class="quest-collapsed-note">Quest log hidden. You can keep exploring freely.</div>
            </div>
            <button id="newGame" type="button">New Game</button>
            <button id="debugOpen" class="secondary" type="button">Systems & Debug</button>
          </div>
        </div>
        <div id="questWidget" class="quest-widget">
          <div class="quest-widget-head">
            <p class="quest-widget-title">Quests</p>
            <button id="questWidgetToggle" class="quest-widget-toggle" type="button" aria-expanded="false">â–¾</button>
          </div>
          <div id="questWidgetList" class="quest-widget-list"></div>
        </div>
        <div class="top-stats-hud">
          <div class="top-stat" id="ecoHud">Eco 5%</div>
          <div class="top-stat" id="wildlifeHud">Wildlife 1</div>
        </div>
        <div id="floatingMessage" class="floating-message">
          <div class="msg-head">
            <p id="message" class="msg-inline">Welcome, Ranger! Clean litter and plant trees to restore the forest.</p>
            <button id="messageToggle" class="msg-toggle" type="button" aria-expanded="false" aria-label="Expand message history">â–¾</button>
          </div>
          <div id="messageHistory" class="msg-history" hidden>No recent events.</div>
        </div>
        <div id="notebookPanel" class="notebook-panel collapsed">
          <div id="notebookTab" class="notebook-tab" role="button" tabindex="0" aria-expanded="false">
            <span id="notebookTabLabel" class="notebook-tab-label">Notebook</span>
            <span class="notebook-tab-mid">
              <button id="notebookPrev" class="notebook-page-btn" type="button" aria-label="Previous notebook page">â—‚</button>
              <span id="notebookPageCount" class="notebook-page-count">0/0</span>
              <button id="notebookNext" class="notebook-page-btn" type="button" aria-label="Next notebook page">â–¸</button>
            </span>
            <span id="notebookTabArrowHit" class="notebook-tab-arrow-hit"><span id="notebookTabArrow">â–´</span></span>
          </div>
          <p id="notebookEmpty" class="notebook-empty">Lets record what we see and what we learn about the forrest, click on an animal or tree to begin!</p>
          <div class="notebook-head">
            <p class="notebook-type"><strong>Type:</strong> <span id="inspectType">-</span></p>
          </div>
          <div class="notebook-body">
            <p class="inspect-line"><strong>Name:</strong> <input id="inspectNameInput" class="profile-input" type="text" maxlength="24" placeholder="Give this one a name" autocomplete="off" disabled></p>
            <p class="inspect-line"><strong>Fact:</strong> <span id="inspectFact">Interesting facts appear here.</span></p>
            <p class="inspect-line"><strong>Observations:</strong> <span id="inspectObservationsBadge" class="obs-badge" hidden>new</span></p>
            <p id="inspectObservationsEmpty" class="inspect-observations-empty">No observations yet. Spend time nearby and check back.</p>
            <ul id="inspectObservations" class="inspect-observations" aria-live="polite"></ul>
            <p id="inspectObservationsTyping" class="inspect-observations-typing" hidden><span></span><span></span><span></span></p>
          </div>
        </div>
        <button id="buildToggle" class="build-fab" type="button" aria-label="Open build menu" aria-expanded="false" hidden>ðŸ”¨</button>
        <div id="buildMenu" class="build-popup" hidden>
          <div id="campsiteList" class="campsite-list"></div>
          <div id="campsiteMode" class="campsite-mode" hidden>Placement mode: click the map to place.</div>
          <div class="campsite-note">Unlock new campsite items by restoring the forest.</div>
        </div>
      </div>
      <div class="touch-controls" aria-label="Mobile controls">
        <div id="joystick" class="joystick" aria-label="Movement joystick">
          <div id="joystickKnob" class="joystick-knob"></div>
        </div>
        <button id="touchInteract" class="touch-action" type="button" aria-label="Interact">Interact</button>
      </div>
    </section>
  </main>

  <div id="startOverlay" class="start-overlay" aria-hidden="true">
    <section class="start-panel">
      <h2>Forrest Clean Up</h2>
      <p>Cleanup and planting gradually heal the forest. Watch life return in real time.</p>
      <label class="menu-label">
        Ranger Name
        <input id="startPlayerName" class="profile-input" type="text" maxlength="22" placeholder="name (optional)" aria-label="Ranger name at start">
      </label>
      <button id="startContinue" type="button">Start</button>
    </section>
  </div>

  <div id="debugOverlay" class="debug-overlay" aria-hidden="true">
    <section class="debug-panel">
      <div class="debug-head">
        <h2 class="debug-title">Systems & Debug</h2>
        <button id="debugClose" class="secondary">Close</button>
      </div>
      <div class="debug-controls">
        <button id="debugStartDay" type="button">Start Day</button>
        <button id="debugStartNight" type="button">Start Night</button>
        <div class="debug-slider">
          <label for="debugEco">Eco Health: <span id="debugEcoValue">5%</span></label>
          <input id="debugEco" type="range" min="0" max="100" step="1" value="5">
        </div>
        <button id="debugStream" type="button">Toggle Stream Outline</button>
      </div>
      <div class="sprite-sample">
        <h3>Sprite Samples</h3>
        <canvas id="spriteSample" width="560" height="220"></canvas>
      </div>
      <div class="debug-grid">
        <div class="debug-box">
          <h3>How Systems Work</h3>
          <p id="debugSystems" class="debug-pre"></p>
        </div>
        <div class="debug-box">
          <h3>Current Playthrough</h3>
          <p id="debugPlaythrough" class="debug-pre"></p>
        </div>
        <div class="debug-box">
          <h3>Active Surprise Queue</h3>
          <p id="debugQueue" class="debug-pre"></p>
        </div>
        <div class="debug-box">
          <h3>Influence + Formula Snapshot</h3>
          <p id="debugInfluence" class="debug-pre"></p>
        </div>
        <div class="debug-box">
          <h3>Triggered Events</h3>
          <p id="debugEvents" class="debug-pre"></p>
        </div>
      </div>
    </section>
  </div>

  <div id="questPopup" class="quest-popup" aria-hidden="true">
    <section class="quest-panel" role="dialog" aria-modal="true" aria-labelledby="questPopupTitle">
      <div class="debug-head">
        <h2 id="questPopupTitle">Quest Details</h2>
        <button id="questPopupClose" class="secondary" type="button">Close</button>
      </div>
      <p id="questPopupBody"></p>
      <p class="quest-progress" id="questPopupProgress"></p>
    </section>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const ui = {
      water: document.getElementById("water"),
      trees: document.getElementById("trees"),
      cleanedStack: document.getElementById("cleanedStack"),
      best: document.getElementById("best"),
      ecoHud: document.getElementById("ecoHud"),
      wildlifeHud: document.getElementById("wildlifeHud"),
      message: document.getElementById("message"),
      messageToggle: document.getElementById("messageToggle"),
      messageHistory: document.getElementById("messageHistory"),
      floatingMessage: document.getElementById("floatingMessage"),
      acornStack: document.getElementById("acornStack"),
      acornPlaceholder: document.getElementById("acornPlaceholder"),
      cleanedPlaceholder: document.getElementById("cleanedPlaceholder"),
      waterIcon: document.getElementById("waterIcon"),
      notebookPanel: document.getElementById("notebookPanel"),
      notebookTab: document.getElementById("notebookTab"),
      notebookTabArrow: document.getElementById("notebookTabArrow"),
      notebookPrev: document.getElementById("notebookPrev"),
      notebookNext: document.getElementById("notebookNext"),
      notebookPageCount: document.getElementById("notebookPageCount"),
      inspectNameInput: document.getElementById("inspectNameInput"),
      inspectType: document.getElementById("inspectType"),
      inspectFact: document.getElementById("inspectFact"),
      inspectObservations: document.getElementById("inspectObservations"),
      inspectObservationsEmpty: document.getElementById("inspectObservationsEmpty"),
      inspectObservationsTyping: document.getElementById("inspectObservationsTyping"),
      inspectObservationsBadge: document.getElementById("inspectObservationsBadge"),
      debugOverlay: document.getElementById("debugOverlay"),
      debugSystems: document.getElementById("debugSystems"),
      debugPlaythrough: document.getElementById("debugPlaythrough"),
      debugQueue: document.getElementById("debugQueue"),
      debugInfluence: document.getElementById("debugInfluence"),
      debugEvents: document.getElementById("debugEvents"),
      debugStartDay: document.getElementById("debugStartDay"),
      debugStartNight: document.getElementById("debugStartNight"),
      debugEco: document.getElementById("debugEco"),
      debugEcoValue: document.getElementById("debugEcoValue"),
      debugStream: document.getElementById("debugStream"),
      spriteSample: document.getElementById("spriteSample"),
      joystick: document.getElementById("joystick"),
      joystickKnob: document.getElementById("joystickKnob"),
      touchInteract: document.getElementById("touchInteract"),
      touchControls: document.querySelector(".touch-controls"),
      touchModeLabel: document.getElementById("touchModeLabel"),
      touchModeToggle: document.getElementById("touchModeToggle"),
      menuToggle: document.getElementById("menuToggle"),
      menuClose: document.getElementById("menuClose"),
      gameMenu: document.getElementById("gameMenu"),
      menuPlayerName: document.getElementById("menuPlayerName"),
      startOverlay: document.getElementById("startOverlay"),
      startPlayerName: document.getElementById("startPlayerName"),
      startContinue: document.getElementById("startContinue"),
      buildToggle: document.getElementById("buildToggle"),
      buildMenu: document.getElementById("buildMenu"),
      campsiteList: document.getElementById("campsiteList"),
      campsiteMode: document.getElementById("campsiteMode"),
      questPanel: document.getElementById("questPanel"),
      questToggle: document.getElementById("questToggle"),
      questCollapsedNote: document.getElementById("questCollapsedNote"),
      questList: document.getElementById("questList"),
      questWidget: document.getElementById("questWidget"),
      questWidgetList: document.getElementById("questWidgetList"),
      questWidgetToggle: document.getElementById("questWidgetToggle"),
      questPopup: document.getElementById("questPopup"),
      questPopupTitle: document.getElementById("questPopupTitle"),
      questPopupBody: document.getElementById("questPopupBody"),
      questPopupProgress: document.getElementById("questPopupProgress"),
      questPopupClose: document.getElementById("questPopupClose")
    };

    const GOAL = { trees: 12, cleaned: 12, eco: 90 };
    const WORLD = { w: 1600, h: 920 };
    const OBSERVATION_UNLOCK_FRAMES = [60 * 45, 60 * 120, 60 * 240, 60 * 420, 60 * 660];
    const NAMED_OBSERVATION_RATE = 2.5;
    let grassPattern = null;
    const CYCLE = {
      dayFrames: 60 * 180,
      nightFrames: 60 * 120,
      transitionFrames: 60 * 28,
      total: (60 * 180) + (60 * 120)
    };

    const state = {
      easyMode: false,
      bestScore: Number(localStorage.getItem("forest-best") || 0),
      won: false,
      t: 0,
      ecoScore: 5,
      celebrationFrames: 0,
      acorns: 0,
      waterCarried: false,
      planted: 0,
      cleaned: 0,
      keys: new Set(),
      player: {
        x: 140,
        y: 620,
        r: 15,
        speed: 2.7,
        color: "#e88434",
        facing: 1,
        moving: false
      },
      acornNodes: [],
      saplingSpots: [],
      litterSpots: [],
      puddles: [],
      leaves: [],
      flowers: [],
      grassTufts: [],
      ferns: [],
      bushes: [],
      meadowGrass: [],
      animals: [],
      fireflies: [],
      hoverTarget: null,
      inspectTarget: null,
      inspectExpanded: false,
      notebookHintUntil: 0,
      notebookObsBadgeUntil: 0,
      notebookHistory: [],
      notebookHistoryIndex: -1,
      mouseWorld: null,
      lastMovementInputFrame: 0,
      surprises: [],
      recentImpacts: [],
      eventLog: [],
      stats: {
        surprisesTriggered: 0,
        flowerSpreadEvents: 0,
        treeAcornDrops: 0,
        wildlifeFromSurprises: 0,
        acornsCollected: 0,
        treesWatered: 0,
        animalsNamed: 0
      },
      debugPanelOpen: false,
      menuOpen: false,
      debugTick: 0,
      lastWiltMessageFrame: -9999,
      noAcornHintUntil: 0,
      basicActionHintsShown: {
        acorn: false,
        plant: false,
        clean: false,
        waterFill: false,
        waterTree: false
      },
      camera: {
        x: 0,
        y: 0,
        zoom: 1
      },
      touch: {
        active: false,
        pointerId: null,
        dx: 0,
        dy: 0
      },
      touchControlsEnabled: localStorage.getItem("forest-touch-controls")
        ? localStorage.getItem("forest-touch-controls") === "on"
        : isMobileViewport(),
      questIndex: 0,
      lastQuestNoticeId: null,
      questUnlocks: {
        afterClean: false,
        afterAcorn: false,
        afterPlant: false,
        afterWilt: false
      },
      questPanelOpen: localStorage.getItem("forest-quest-panel") === "open",
      questWidgetExpanded: false,
      playerName: "",
      saveLoaded: false,
      saveTimer: null,
      lastSaveFrame: 0,
      campsiteItems: [],
      buildMode: null,
      stream: null,
      trash: {
        nextSpawnFrame: 0,
        introShown: false,
        raccoonIntroShown: false
      },
      nextFlowerSpreadFrame: 0,
      butterflyBurstDone: false,
      butterflyBurstPending: false,
      nextRareAnimalFrame: 0,
      nextWiltAllowedFrame: 0,
      observationLedger: {
        used: {},
        serial: 1
      },
      debugStreamOutline: false
    };

    const QUESTS = [
      {
        id: "clean-trailhead",
        title: "Clean the Trailhead",
        short: "Clean 3 litter spots.",
        detail: "Start with the busiest area. Clear out three litter spots to make the forest welcoming for visitors and wildlife.",
        goal: { type: "clean", target: 3, label: "litter cleared" },
        unlock: "start"
      },
      {
        id: "collect-acorns",
        title: "Gather Acorns",
        short: "Pick up 3 acorns.",
        detail: "Move close to acorn piles and interact to collect them. You'll need acorns to plant new trees.",
        goal: { type: "acorn", target: 3, label: "acorns collected" },
        unlock: "afterClean"
      },
      {
        id: "first-grove",
        title: "Plant the First Grove",
        short: "Plant 8 trees.",
        detail: "Find planting spots and interact to plant trees. Build a fuller starter grove so canopy recovery becomes visible across the map.",
        goal: { type: "plant", target: 8, label: "trees planted" },
        unlock: "afterAcorn"
      },
      {
        id: "water-helpers",
        title: "Water the Trees",
        short: "Water 4 thirsty trees.",
        detail: "Some young trees get thirsty. Refill your water at a pond or stream, then keep four trees from drying out.",
        goal: { type: "water", target: 4, label: "trees watered" },
        unlock: "afterWilt"
      },
      {
        id: "steady-care",
        title: "Steady Care",
        short: "Clean 16 litter spots.",
        detail: "Keep the momentum going. Clean a total of sixteen litter spots to push recovery past the trailhead and into the wider forest.",
        goal: { type: "clean", target: 16, label: "litter cleared" },
        unlock: "afterPlant"
      },
      {
        id: "restoration-boost",
        title: "Restoration Boost",
        short: "Reach 60% Eco Health.",
        detail: "A healthier forest means more wildlife and stronger regrowth. Reach 60% Eco Health and watch the map visibly thicken with life.",
        goal: { type: "eco", target: 60, label: "eco health" },
        unlock: "afterPlant"
      },
      {
        id: "community-forest",
        title: "Community Forest",
        short: "Plant 20 trees.",
        detail: "Expand the new grove. Plant twenty trees to build a lasting canopy and stabilize more of the forest floor.",
        goal: { type: "plant", target: 20, label: "trees planted" },
        unlock: "afterPlant"
      },
      {
        id: "name-an-animal",
        title: "Name a Neighbor",
        short: "Name 1 animal.",
        detail: "Use the notebook to name one animal you notice. Start building your own field guide as the forest recovers.",
        goal: { type: "nameAnimal", target: 1, label: "animals named" },
        unlock: "afterPlant"
      },
      {
        id: "full-restoration",
        title: "Full Restoration",
        short: "Reach 100% Eco Health.",
        detail: "Bring the whole map to full recovery. Reach 100% Eco Health through steady cleanup, planting, watering, and observation.",
        goal: { type: "eco", target: 100, label: "eco health" },
        unlock: "afterPlant"
      }
    ];

    const QUEST_LOOKUP = Object.fromEntries(QUESTS.map((quest) => [quest.id, quest]));

    const WATER = {
      wiltDelayMin: 60 * 60,
      wiltDelayMax: 60 * 120,
      wiltChance: 0.45,
      easyWiltChance: 0.25,
      maxWilted: 4,
      transitionFrames: 60 * 2,
      postWaterGraceFrames: 60 * 10
    };

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function makeStreamDashPattern() {
      return [
        2 + rand(0, 3),
        8 + rand(0, 8),
        5 + rand(0, 5),
        14 + rand(0, 10),
        3 + rand(0, 3),
        22 + rand(0, 14),
        7 + rand(0, 6),
        6 + rand(0, 6),
        4 + rand(0, 4),
        18 + rand(0, 12),
        9 + rand(0, 6),
        10 + rand(0, 8)
      ];
    }

    function makeStreamFlowMarks() {
      const marks = [];
      const count = 24;
      for (let i = 0; i < count; i++) {
        const base = i / count;
        const spacingJitter = rand(-0.006, 0.006);
        marks.push({
          // Keep spacing mostly even along the stream, with tiny jitter.
          base: clamp(base + spacingJitter, 0, 1),
          // Increase per-mark length variation.
          length: 3 + rand(0, 14),
          phase: rand(0, Math.PI * 2),
          amp: 0.6 + rand(0, 1.4)
        });
      }
      return marks;
    }

    function createStream() {
      const edgeInset = -26;
      const randomEdgePoint = (edge) => {
        switch (edge) {
          case "left":
            return { x: edgeInset, y: rand(120, WORLD.h - 120) };
          case "right":
            return { x: WORLD.w - edgeInset, y: rand(120, WORLD.h - 120) };
          case "top":
            return { x: rand(120, WORLD.w - 120), y: edgeInset };
          default:
            return { x: rand(120, WORLD.w - 120), y: WORLD.h - edgeInset };
        }
      };

      const edges = ["left", "right", "top", "bottom"];
      let start = null;
      let end = null;
      let attempts = 0;
      while (attempts < 20) {
        const edgeA = edges[Math.floor(rand(0, 4))];
        const adjacent = edgeA === "left" || edgeA === "right"
          ? ["top", "bottom"]
          : ["left", "right"];
        const edgeB = adjacent[Math.floor(rand(0, adjacent.length))];
        start = randomEdgePoint(edgeA);
        end = randomEdgePoint(edgeB);
        if (Math.hypot(end.x - start.x, end.y - start.y) > WORLD.w * 0.5) break;
        attempts += 1;
      }

      const dx = end.x - start.x;
      const dy = end.y - start.y;
      const len = Math.max(1, Math.hypot(dx, dy));
      const nx = -dy / len;
      const ny = dx / len;
      const bendCount = len > WORLD.w * 0.75 ? 4 : 3;
      const points = [];
      points.push(start);
      for (let i = 1; i <= bendCount; i++) {
        const t = i / (bendCount + 1);
        const offset = rand(-60, 60);
        points.push({
          x: clamp(start.x + dx * t + nx * offset, 80, WORLD.w - 80),
          y: clamp(start.y + dy * t + ny * offset, 80, WORLD.h - 80)
        });
      }
      points.push(end);

      return {
        points,
        width: rand(24, 32),
        // Fixed per-stream irregular dash/gap sequence for visible within-stream variation.
        dashPattern: makeStreamDashPattern(),
        flowMarks: makeStreamFlowMarks(),
        flowMarksVersion: 2
      };
    }

    function smoothstep(t) {
      const x = clamp(t, 0, 1);
      return x * x * (3 - 2 * x);
    }

    function mixColor(dayRgb, nightRgb, nightAmount) {
      const n = clamp(nightAmount, 0, 1);
      const d = 1 - n;
      const r = Math.round(dayRgb[0] * d + nightRgb[0] * n);
      const g = Math.round(dayRgb[1] * d + nightRgb[1] * n);
      const b = Math.round(dayRgb[2] * d + nightRgb[2] * n);
      return "rgb(" + r + ", " + g + ", " + b + ")";
    }

    function blendRgb(fromRgb, toRgb, t) {
      const p = clamp(t, 0, 1);
      const q = 1 - p;
      return [
        Math.round(fromRgb[0] * q + toRgb[0] * p),
        Math.round(fromRgb[1] * q + toRgb[1] * p),
        Math.round(fromRgb[2] * q + toRgb[2] * p)
      ];
    }

    const PAPER = {
      groundDay: [122, 170, 120],
      groundNight: [30, 52, 40],
      grassDay: [94, 151, 104],
      grassNight: [35, 69, 52],
      canopyA: [92, 155, 106],
      canopyB: [79, 131, 93],
      canopyNight: [44, 87, 62],
      trunk: [110, 80, 48],
      trunkNight: [74, 58, 40],
      litter: [214, 180, 138],
      litterLine: [160, 128, 92],
      flowerStem: [92, 130, 90],
      waterDay: [116, 168, 197],
      waterNight: [54, 96, 126]
    };

    function drawShadowEllipse(x, y, rx, ry, alpha) {
      return;
    }

    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function randomFrom(items) {
      return items[Math.floor(rand(0, items.length))];
    }

    function isMobileViewport() {
      return window.matchMedia("(hover: none), (pointer: coarse)").matches;
    }

    function updatePlayUiScale() {
      const viewportW = window.visualViewport ? window.visualViewport.width : window.innerWidth;
      const w = viewportW || canvas.getBoundingClientRect().width || 1600;
      // Scale in the 300-1000px viewport range; clamp outside it.
      const scale = clamp((w - 300) / (1000 - 300), 0.62, 1);
      document.documentElement.style.setProperty("--play-ui-scale", scale.toFixed(3));
    }

    function syncCanvasSize() {
      const targetW = isMobileViewport() ? Math.max(320, Math.round(window.innerWidth)) : WORLD.w;
      const targetH = isMobileViewport() ? Math.max(320, Math.round(window.innerHeight)) : WORLD.h;
      if (canvas.width !== targetW || canvas.height !== targetH) {
        canvas.width = targetW;
        canvas.height = targetH;
      }
      updatePlayUiScale();
    }

    function updateCamera() {
      syncCanvasSize();
      const zoom = isMobileViewport() ? 1.45 : 1;
      const viewW = canvas.width / zoom;
      const viewH = canvas.height / zoom;
      const maxX = Math.max(0, WORLD.w - viewW);
      const maxY = Math.max(0, WORLD.h - viewH);
      state.camera.zoom = zoom;
      state.camera.x = clamp(state.player.x - viewW / 2, 0, maxX);
      state.camera.y = clamp(state.player.y - viewH / 2, 0, maxY);
    }

    function ensureGrassPattern() {
      if (grassPattern) return grassPattern;
      const tile = document.createElement("canvas");
      tile.width = 88;
      tile.height = 88;
      const tctx = tile.getContext("2d");
      tctx.clearRect(0, 0, tile.width, tile.height);

      for (let i = 0; i < 120; i++) {
        const x = rand(0, tile.width);
        const y = rand(0, tile.height);
        const len = rand(2, 7);
        const tilt = rand(-0.65, 0.65);
        tctx.strokeStyle = rand(0, 1) > 0.5 ? "rgba(255, 255, 255, 0.16)" : "rgba(19, 56, 32, 0.14)";
        tctx.lineWidth = rand(0, 1) > 0.5 ? 0.85 : 1.1;
        tctx.beginPath();
        tctx.moveTo(x, y);
        tctx.lineTo(x + tilt * 1.9, y - len);
        tctx.stroke();
      }

      for (let i = 0; i < 42; i++) {
        tctx.fillStyle = rand(0, 1) > 0.5 ? "rgba(255, 255, 255, 0.1)" : "rgba(14, 39, 24, 0.08)";
        tctx.beginPath();
        tctx.arc(rand(0, tile.width), rand(0, tile.height), rand(0.5, 1.6), 0, Math.PI * 2);
        tctx.fill();
      }

      grassPattern = ctx.createPattern(tile, "repeat");
      return grassPattern;
    }

    function setMenuOpen(open) {
      state.menuOpen = Boolean(open);
      ui.gameMenu.hidden = !state.menuOpen;
      ui.menuToggle.setAttribute("aria-expanded", state.menuOpen ? "true" : "false");
    }

    function syncNameInputs() {
      ui.menuPlayerName.value = state.playerName || "";
      ui.startPlayerName.value = state.playerName || "";
    }

    function setPlayerName(name) {
      state.playerName = String(name || "").trim();
      syncNameInputs();
      scheduleSave();
    }

    function openStartOverlay() {
      syncNameInputs();
      ui.startOverlay.classList.add("open");
      ui.startOverlay.setAttribute("aria-hidden", "false");
      setMenuOpen(false);
    }

    function closeStartOverlay() {
      ui.startOverlay.classList.remove("open");
      ui.startOverlay.setAttribute("aria-hidden", "true");
    }

    const ANIMAL_FACTS = {
      rabbit: "Rabbits can rotate their ears to detect sounds from many directions.",
      bird: "Many birds spread seeds when they eat fruit, helping forests regrow.",
      deer: "Deer can run quickly and use strong smell to detect predators.",
      fox: "Foxes use excellent hearing to locate tiny animals under leaves and snow.",
      owl: "Owls can turn their heads far to scan the forest at night.",
      squirrel: "Squirrels hide nuts and forget some, which helps trees spread.",
      raccoon: "Raccoons are clever foragers with very sensitive front paws.",
      bear: "Bears can spread seeds long distances as they move across habitats.",
      moose: "Moose browse young shoots and help shape forest plant growth.",
      bee: "Bees help pollinate plants, supporting healthy forests.",
      butterfly: "Butterflies are gentle pollinators that thrive in healthy habitats."
    };


    const RARE_WILDLIFE = {
      minIntervalFrames: 60 * 60 * 45,
      maxIntervalFrames: 60 * 60 * 75,
      minStayFrames: 60 * 120,
      maxStayFrames: 60 * 240
    };

    const TREE_TYPES = ["Oak", "Pine", "Maple", "Birch", "Cedar", "Aspen"];
    const TREE_FACTS = {
      Oak: "Oak trees can support hundreds of different insects, birds, and small animals.",
      Pine: "Pine needles stay year-round and help protect soil during cold seasons.",
      Maple: "Maple trees provide shade that helps keep forest floors cool and moist.",
      Birch: "Birch trees are often among the first to grow back in recovering forests.",
      Cedar: "Cedar trees provide shelter for wildlife and can live for many years.",
      Aspen: "Aspen trees often grow in connected groves that share root systems."
    };
    function makeTreeProfile() {
      const type = randomFrom(TREE_TYPES);
      return {
        treeType: type,
        customName: "",
        treeFact: TREE_FACTS[type]
      };
    }

    function createAnimal(type, x, y, extra = {}) {
      const isBee = type === "bee";
      const isRaccoon = type === "raccoon";
      const isOwl = type === "owl";
      return {
        x,
        y,
        vx: rand(isBee ? -0.8 : -0.9, isBee ? 0.8 : 0.9),
        vy: rand(isBee ? -0.6 : -0.6, isBee ? 0.6 : 0.6),
        type,
        customName: "",
        everNamed: false,
        fact: ANIMAL_FACTS[type],
        nightOnly: type === "owl",
        bob: rand(0, Math.PI * 2),
        ttl: extra.ttl ?? null,
        expiring: false,
        alpha: extra.spawnFade ? 0 : (extra.alpha ?? 1),
        visibleTarget: extra.visibleTarget ?? true,
        fadeDelay: 0,
        nextTrashDropFrame: isRaccoon ? (state.t + Math.floor(rand(60 * 240, 60 * 540))) : null,
        glideTarget: isOwl ? { x: x, y: y } : null,
        nextGlideRetargetFrame: isOwl ? (state.t + Math.floor(rand(60 * 4, 60 * 8))) : 0
      };
    }

    function createFirefly() {
      return {
        x: rand(20, WORLD.w - 20),
        y: rand(70, WORLD.h - 20),
        vx: rand(-0.35, 0.35),
        vy: rand(-0.25, 0.25),
        phase: rand(0, Math.PI * 2),
        pulse: rand(0.03, 0.08),
        alpha: 0,
        visibleTarget: true,
        fadeDelay: Math.floor(rand(0, 60))
      };
    }

    function getCycleInfo() {
      const frame = state.t % CYCLE.total;
      const isNight = frame >= CYCLE.dayFrames;
      const cycleProgress = frame / CYCLE.total;
      if (!isNight) {
        return {
          isNight,
          frame,
          cycleProgress,
          phase: frame / CYCLE.dayFrames
        };
      }
      return {
        isNight,
        frame,
        cycleProgress,
        phase: (frame - CYCLE.dayFrames) / CYCLE.nightFrames
      };
    }

    function getDaylightLevel() {
      const frame = state.t % CYCLE.total;
      const dawn = CYCLE.transitionFrames;
      const duskStart = CYCLE.dayFrames - CYCLE.transitionFrames;
      const dawnStart = CYCLE.total - CYCLE.transitionFrames;

      if (frame < CYCLE.dayFrames) {
        if (frame > duskStart) {
          return 1 - smoothstep((frame - duskStart) / CYCLE.transitionFrames);
        }
        return 1;
      }
      if (frame >= dawnStart) {
        return smoothstep((frame - dawnStart) / dawn);
      }
      return 0;
    }

    function getInteractableAnimals() {
      const cycle = getCycleInfo();
      return state.animals.filter((animal) => {
        if ((animal.alpha ?? 0) <= 0.05) return false;
        return cycle.isNight ? animal.nightOnly : !animal.nightOnly;
      });
    }

    function getVisibleAnimals() {
      return state.animals.filter((animal) => {
        return (animal.alpha ?? 0) > 0.05;
      });
    }

    function getObservationPool(ref) {
      if (!ref) return [];
      const treeType = typeof ref.treeType === "string" ? ref.treeType.toLowerCase() : "";
      const animalType = typeof ref.type === "string" ? ref.type.toLowerCase() : "";

      if (treeType) {
        const treePool = [
          "Leaves shimmer in waves, like the whole tree is whispering.",
          "Small ant trails keep rerouting around the base roots here.",
          "Wind in this canopy sounds like layered paper rustling.",
          "Air feels cooler under this canopy, even at midday.",
          "Bird calls repeat from this spot like a small forest chorus.",
          "Soil here stays darker longer after rain.",
          "Fallen leaves are building a softer forest floor each day.",
          "Shade moves slowly here, like a sundial made of branches.",
          "Sunlight slips through in tiny moving patches on the ground.",
          "Ground cover near the roots looks greener than nearby patches.",
          "A resin scent lingers longer on warm afternoons.",
          "Bark texture feels rougher on the wind-facing side.",
          "Tiny insects seem to choose this trunk as a meeting spot.",
          "Raindrops collect on lower leaves before finally letting go.",
          "A quiet creak shows up right before stronger gusts.",
          "The root flare creates a small sheltered pocket of calm air.",
          "Light at dusk gives the bark a warm copper glow.",
          "New leaf tips are catching more morning light than before.",
          "Needles and leaves here muffle footsteps more than open ground.",
          "Shadow edges under this tree look softer near sunset.",
          "Nearby flowers lean slightly toward this open patch of light.",
          "A faint earthy smell gets stronger after evening dew.",
          "The canopy seems to sway in slow layers instead of one piece.",
          "Moisture hangs in the air here a little longer at dawn.",
          "Moss flecks are starting to map out little constellations on the bark."
        ];
        const treeTypeExtras = {
          aspen: [
            "Leaves flicker like tiny mirrors when the breeze picks up.",
            "Trunk catches dusk light and flashes a pale silver tone.",
            "Whole crown trembles lightly even when nearby trees stay still.",
            "Bark markings look like hand-drawn brushstrokes up close."
          ],
          pine: [
            "Pine scent sharpens right after sunrise.",
            "Cones look more open on bright, dry afternoons.",
            "Needle clusters hiss softly in stronger wind.",
            "Ground below has a springy feel from layered needles."
          ],
          maple: [
            "Leaf shadows land in star-like shapes near late afternoon.",
            "Canopy color shifts faster than expected as the light changes.",
            "Branches hold a gentle amber tint near sunset.",
            "Pollinator traffic rises when nearby flowers open."
          ],
          birch: [
            "Bark peels in thin curls that catch sunlight.",
            "White bark glows brighter than neighboring trunks at dusk.",
            "Fine twigs draw delicate lines against the sky.",
            "A papery rustle starts early when wind picks up."
          ],
          cedar: [
            "Dense sprays of foliage make this spot feel hushed.",
            "A warm, spicy wood scent sits close to the trunk.",
            "Shade here stays cool even during brighter hours.",
            "Lower branches create small sheltered nooks."
          ],
          oak: [
            "Branch shapes cast bold, puzzle-piece shadows.",
            "Acorn caps and fragments are beginning to gather below.",
            "Canopy movement feels slower and heavier than nearby trees.",
            "Trunk grooves hold tiny pockets of moisture after rain."
          ]
        };
        return treePool.concat(treeTypeExtras[treeType] || []);
      }

      if (animalType) {
        const animalPool = [
          "Pauses to listen, then slips forward like it heard a secret.",
          "Follows almost the same route, like a tiny patrol loop.",
          "Nearby birds shift position when it enters this area.",
          "Acts bolder in thicker grass than in open clearings.",
          "Lingers longer near healthier flower patches.",
          "Moves in short bursts, then holds still to scan.",
          "Favors edge cover over wide open ground.",
          "Returns to one resting spot between short loops.",
          "Keeps to the edge where meadow meets shade, then vanishes.",
          "Does a quick side-step when startled, then acts normal again.",
          "Trots three steps, then pauses like it heard applause.",
          "Takes the wiggliest path instead of the shortest one.",
          "Sneaks low through plants, then pops up suddenly.",
          "Tests the ground with little taps before moving on.",
          "Circles back to changed places, curious every time.",
          "Hesitates at bright open patches, then darts through.",
          "Picks one narrow corridor and reuses it repeatedly.",
          "Movement grows smoother near dense flowers.",
          "Stillness lasts longer right before quick direction changes.",
          "Doubles back once, then commits to a longer route.",
          "Checks the same landmark before leaving the area.",
          "Paces feel lighter on soft ground near the stream.",
          "Keeps a wider arc around noisy activity.",
          "Stops at scent-rich spots for an extra beat.",
          "Paths look playful, like a trail doodled across the grass."
        ];
        const quirkyPool = [
          "Doing that funny freeze-hop-freeze routine like it forgot the next step.",
          "Pretending to be invisible behind grass that is definitely too short.",
          "Investigating the same twig every pass like it is important business.",
          "Spinning a tiny circle, then choosing a brand-new direction.",
          "Returning to this spot and repeating the same odd little routine.",
          "Pausing mid-step like it remembered something, then continuing anyway.",
          "Dodging one leaf dramatically, then ignoring five bigger ones.",
          "Taking a confident path, then changing its mind halfway through.",
          "Making a quick zig, then a slower zag, then pretending that was the plan.",
          "Doing a tiny bounce before each longer move.",
          "Stopping to stare at nothing, then scooting off with urgency.",
          "Looping around one patch like it is checking invisible checkpoints."
        ];
        const animalTypeExtras = {
          fox: [
            "Head tilts before direction changes, as if triangulating sound.",
            "Checks wind direction before crossing open ground.",
            "Tail line stays level during steady patrol pace.",
            "Pauses at higher spots to scan before moving again."
          ],
          rabbit: [
            "Ears swivel constantly, like little radar dishes.",
            "Freezes completely, then commits to a sudden zigzag.",
            "Nibbles quickly, then bolts a short distance to repeat.",
            "Keeps picking sheltered routes through low cover."
          ],
          raccoon: [
            "Uses quick paw taps to test objects before committing.",
            "Circles back to recently changed spots.",
            "Paws linger on edges and corners as if reading texture.",
            "Detours toward interesting clutter even when path is longer."
          ],
          bird: [
            "Chooses higher perches before short gliding descents.",
            "Call rhythm tightens before sudden turns.",
            "Wingbeats switch from quick bursts to longer glides.",
            "Hops closer in short steps before taking off."
          ],
          bee: [
            "Repeats a compact loop before picking the next flower.",
            "Flight path steadies near dense bloom clusters.",
            "Brief hover checks happen just before landing.",
            "Routes look like tiny stitched lines through petals."
          ],
          butterfly: [
            "Drifts side-to-side on sunny paths.",
            "Returns to one warm patch before wandering again.",
            "Wing rhythm slows in calmer, sheltered air.",
            "Floats higher when crossing open light."
          ],
          owl: [
            "Holds still for long beats, then repositions in silence.",
            "Head turns first, body follows in one clean motion.",
            "Perch changes favor darker, quieter routes.",
            "Drops to lower branches only for brief checks."
          ],
          bat: [
            "Flight traces broad arcs, then snaps into tight pivots.",
            "Rechecks the same corridor like a mapped lane.",
            "Turns sharpen near obstacles, then relax in open air.",
            "Loop size narrows around active insect patches."
          ],
          bear: [
            "Pauses longer at scent-rich spots than expected.",
            "Moves surprisingly quietly through dense cover.",
            "Route bends toward berry-rich edges and damp ground.",
            "Shoulder sway becomes slower before longer stops."
          ],
          moose: [
            "Chooses wetter ground edges before entering open areas.",
            "Browses slowly, then takes one long decisive stride.",
            "Lingers in cool shade pockets during brighter hours.",
            "Path prefers soft ground near water channels."
          ]
        };
        return animalPool.concat(quirkyPool, animalTypeExtras[animalType] || []);
      }

      return [];
    }

    function shuffledSample(list, count) {
      const copy = list.slice();
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(rand(0, i + 1));
        const temp = copy[i];
        copy[i] = copy[j];
        copy[j] = temp;
      }
      return copy.slice(0, count);
    }

    function buildFallbackObservation(ref) {
      const serial = state.observationLedger.serial++;
      const isTree = typeof ref.treeType === "string";
      const label = isTree
        ? (ref.customName || (ref.treeType + " tree"))
        : (ref.customName || (ref.type ? ref.type.charAt(0).toUpperCase() + ref.type.slice(1) : "animal"));
      const moods = ["quiet", "windy", "sunny", "cool", "misty", "bright", "still", "rain-washed"];
      const textures = ["the air feels softer", "sounds carry farther", "the ground smells richer", "movement feels calmer", "the light sits lower"];
      const mood = moods[Math.floor(rand(0, moods.length))];
      const texture = textures[Math.floor(rand(0, textures.length))];
      return "Field note " + serial + ": Around " + label + " during " + mood + " moments, " + texture + ".";
    }

    function pickUniqueObservations(ref, count) {
      const pool = shuffledSample(getObservationPool(ref), 999);
      const picked = [];
      for (const line of pool) {
        if (picked.length >= count) break;
        if (state.observationLedger.used[line]) continue;
        picked.push(line);
        state.observationLedger.used[line] = true;
      }
      while (picked.length < count) {
        const fallback = buildFallbackObservation(ref);
        if (state.observationLedger.used[fallback]) continue;
        picked.push(fallback);
        state.observationLedger.used[fallback] = true;
      }
      return picked;
    }

    function unlockObservations(ref) {
      if (!ref || typeof ref.observedSinceFrame !== "number") return false;
      if (!Array.isArray(ref.observationPlan)) return false;
      if (!Array.isArray(ref.observations)) ref.observations = [];
      const namedBoost = ref.customName && ref.customName.trim() ? NAMED_OBSERVATION_RATE : 1;
      const elapsed = Math.max(0, state.t - ref.observedSinceFrame) * namedBoost;
      const targetCount = OBSERVATION_UNLOCK_FRAMES.reduce((count, frame) => {
        return count + (elapsed >= frame ? 1 : 0);
      }, 0);
      let changed = false;
      while (ref.observations.length < targetCount && ref.observations.length < ref.observationPlan.length) {
        ref.observations.push(ref.observationPlan[ref.observations.length]);
        changed = true;
      }
      if (changed && state.inspectTarget === ref) {
        state.notebookObsBadgeUntil = state.t + 60 * 3;
      }
      return changed;
    }

    function ensureObservationData(ref) {
      if (!ref) return;
      if (typeof ref.observedSinceFrame !== "number") {
        ref.observedSinceFrame = state.t;
      }
      if (!Array.isArray(ref.observations)) {
        ref.observations = [];
      }
      if (!Array.isArray(ref.observationPlan) || ref.observationPlan.length < 5) {
        ref.observationPlan = pickUniqueObservations(ref, 5);
      }
      unlockObservations(ref);
    }

    function renderInspectObservations() {
      const target = state.inspectTarget;
      ui.inspectObservations.innerHTML = "";
      if (!target) {
        ui.inspectObservationsEmpty.hidden = false;
        ui.inspectObservationsTyping.hidden = true;
        ui.inspectObservationsBadge.hidden = true;
        return;
      }
      ensureObservationData(target);
      const entries = Array.isArray(target.observations) ? target.observations : [];
      const planCount = Array.isArray(target.observationPlan) ? target.observationPlan.length : 0;
      ui.inspectObservationsEmpty.hidden = entries.length > 0;
      ui.inspectObservationsBadge.hidden = !(state.t < state.notebookObsBadgeUntil);
      ui.inspectObservationsTyping.hidden = !(planCount > entries.length);
      for (const line of entries) {
        const item = document.createElement("li");
        item.textContent = line;
        ui.inspectObservations.appendChild(item);
      }
    }

    function getInspectMetaForRef(ref) {
      if (!ref) return { title: "Nature Notebook", type: "-", fact: "Interesting facts appear here." };
      if (ref.treeType) {
        return {
          title: "Tree Notes",
          type: ref.treeType + " Tree",
          fact: ref.treeFact || "Interesting facts appear here."
        };
      }
      if (ref.type) {
        const label = ref.type.charAt(0).toUpperCase() + ref.type.slice(1);
        return {
          title: "Animal Notes",
          type: label,
          fact: ref.fact || "Interesting facts appear here."
        };
      }
      return { title: "Nature Notebook", type: "-", fact: "Interesting facts appear here." };
    }

    function addNotebookHistory(ref) {
      if (!ref) return;
      const idx = state.notebookHistory.indexOf(ref);
      if (idx >= 0) {
        state.notebookHistoryIndex = idx;
        return;
      }
      state.notebookHistory.push(ref);
      state.notebookHistoryIndex = state.notebookHistory.length - 1;
    }

    function renderNotebookPager() {
      const total = state.notebookHistory.length;
      if (!total) {
        ui.notebookPageCount.textContent = "0/0";
        ui.notebookPrev.disabled = true;
        ui.notebookNext.disabled = true;
        return;
      }
      const page = clamp(state.notebookHistoryIndex + 1, 1, total);
      ui.notebookPageCount.textContent = page + "/" + total;
      const canFlip = total > 1;
      ui.notebookPrev.disabled = !canFlip;
      ui.notebookNext.disabled = !canFlip;
    }

    function flipNotebookHistory(delta) {
      if (!state.notebookHistory.length) return;
      if (state.notebookHistoryIndex < 0) {
        state.notebookHistoryIndex = state.notebookHistory.length - 1;
      }
      const total = state.notebookHistory.length;
      const next = (state.notebookHistoryIndex + delta + total) % total;
      state.notebookHistoryIndex = next;
      const target = state.notebookHistory[next];
      if (!target) return;
      const meta = getInspectMetaForRef(target);
      setInspectCard(meta.title, meta.type, meta.fact, target, false, false);
    }

    function setInspectCard(title, type, fact, ref = null, showExpandHint = false, trackHistory = true) {
      ui.inspectType.textContent = type;
      ui.inspectFact.textContent = fact;
      state.inspectTarget = ref || null;
      if (state.inspectTarget) {
        if (trackHistory) addNotebookHistory(state.inspectTarget);
        state.notebookObsBadgeUntil = 0;
        ensureObservationData(state.inspectTarget);
        ui.notebookPanel.classList.add("has-selection");
        ui.notebookPanel.classList.toggle("expanded", state.inspectExpanded);
        ui.notebookPanel.classList.toggle("peek", !state.inspectExpanded);
        ui.notebookPanel.classList.remove("collapsed");
        ui.notebookTab.setAttribute("aria-expanded", state.inspectExpanded ? "true" : "false");
        ui.notebookTabArrow.textContent = state.inspectExpanded ? "â–¾" : "â–´";
        if (!state.inspectExpanded && showExpandHint) {
          state.notebookHintUntil = state.t + 60 * 3;
        }
        ui.inspectNameInput.disabled = false;
        ui.inspectNameInput.placeholder = "Give this " + type.toLowerCase() + " a name";
        ui.inspectNameInput.value = state.inspectTarget.customName || "";
      } else {
        ui.notebookPanel.classList.remove("has-selection");
        if (trackHistory) {
          state.notebookHistory = [];
          state.notebookHistoryIndex = -1;
        }
        state.inspectExpanded = false;
        state.notebookHintUntil = 0;
        ui.notebookPanel.classList.remove("expanded");
        ui.notebookPanel.classList.remove("peek");
        ui.notebookPanel.classList.add("collapsed");
        ui.notebookTab.setAttribute("aria-expanded", "false");
        ui.notebookTabArrow.textContent = "â–´";
        ui.inspectNameInput.value = "";
        ui.inspectNameInput.placeholder = "Click an animal or planted tree";
        ui.inspectNameInput.disabled = true;
      }
      renderNotebookPager();
      renderInspectObservations();
    }

    function formatClock(totalSeconds) {
      const s = Math.max(0, Math.floor(totalSeconds));
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      return h + ":" + String(m).padStart(2, "0");
    }

    function normalizeLegacyLogLine(line) {
      const match = /^t\+(\d+)s:\s*(.*)$/.exec(String(line || ""));
      if (!match) return line;
      return formatClock(Number(match[1])) + ": " + match[2];
    }

    function logImpact(text) {
      state.recentImpacts.unshift(formatClock(state.t / 60) + ": " + text);
      state.recentImpacts = state.recentImpacts.slice(0, 6);
      renderMessageLog();
    }

    function logEvent(text) {
      state.eventLog.unshift(formatClock(state.t / 60) + ": " + text);
      state.eventLog = state.eventLog.slice(0, 20);
    }

    function introGrow(entity, frames = 150) {
      if (!entity || typeof entity.spawnAt !== "number") return 1;
      return smoothstep(clamp((state.t - entity.spawnAt) / frames, 0, 1));
    }

    function normalizeDecorationSpawnTimes() {
      const settledAt = state.t - 9999;
      for (const tuft of state.grassTufts) {
        if (typeof tuft.spawnAt !== "number") tuft.spawnAt = settledAt;
      }
      for (const bush of state.bushes) {
        if (typeof bush.spawnAt !== "number") bush.spawnAt = settledAt;
      }
      for (const meadow of state.meadowGrass) {
        if (typeof meadow.spawnAt !== "number") meadow.spawnAt = settledAt;
      }
    }

    function scheduleSurprise(kind, delayFrames, payload) {
      state.surprises.push({
        id: "s-" + Math.floor(rand(1000, 9999999)),
        kind,
        at: state.t + delayFrames,
        payload
      });
      logEvent("Queued surprise: " + kind + " (" + Math.round(delayFrames / 60) + "s)");
    }

    function nearestPond(point, maxDist) {
      let best = null;
      let bestDist = maxDist;
      for (const puddle of state.puddles) {
        const d = distance(point, puddle);
        if (d < bestDist) {
          bestDist = d;
          best = puddle;
        }
      }

      return best;
    }

    function pondWithin(point, buffer) {
      for (const puddle of state.puddles) {
        if (distance(point, puddle) <= puddle.r + buffer) return puddle;
      }
      return null;
    }

    function streamWithin(point, buffer) {
      if (isInStream(point, buffer)) return true;
      return false;
    }

    function countWiltedPlants() {
      return state.saplingSpots.filter((spot) => spot.wilted).length;
    }

    function spawnWorld() {
      state.stream = createStream();
      const pondCount = 2 + Math.floor(rand(0, 2));
      state.puddles = [];
      for (let i = 0; i < pondCount; i++) {
        let candidate = null;
        for (let attempt = 0; attempt < 12; attempt++) {
          const pt = { x: rand(110, WORLD.w - 110), y: rand(110, WORLD.h - 90) };
          if (isInStream(pt, 30)) continue;
          let overlaps = false;
          for (const pond of state.puddles) {
            if (Math.hypot(pt.x - pond.x, pt.y - pond.y) < pond.r + 46) {
              overlaps = true;
              break;
            }
          }
          if (!overlaps) {
            candidate = pt;
            break;
          }
        }
        if (candidate) {
          state.puddles.push({
            x: candidate.x,
            y: candidate.y,
            r: rand(26, 44)
          });
        }
      }

      state.acornNodes = [];
      for (let i = 0; i < 26; i++) {
        let candidate = null;
        for (let attempt = 0; attempt < 12; attempt++) {
          const pt = { x: rand(60, WORLD.w - 60), y: rand(60, WORLD.h - 60) };
          if (!isInWater(pt, 10)) {
            candidate = pt;
            break;
          }
        }
        if (candidate) {
          state.acornNodes.push({
            x: candidate.x,
            y: candidate.y,
            active: true,
            pulse: rand(0, Math.PI * 2)
          });
        }
      }

      state.saplingSpots = [];
      for (let i = 0; i < 48; i++) {
        let candidate = null;
        for (let attempt = 0; attempt < 12; attempt++) {
          const pt = { x: rand(80, WORLD.w - 80), y: rand(80, WORLD.h - 80) };
          if (!isTreeTrunkOverWater(pt)) {
            candidate = pt;
            break;
          }
        }
        if (candidate) {
          state.saplingSpots.push({
            x: candidate.x,
            y: candidate.y,
            planted: false,
            growth: 0,
            acornDropped: false,
            wilted: false,
            wiltBlend: 0,
            needsWater: false,
            wiltAt: 0,
            lastWateredAt: -999999,
            ...makeTreeProfile()
          });
        }
      }

      const starterTrees = Math.min(12, state.saplingSpots.length);
      const starterIndices = state.saplingSpots
        .map((_, idx) => idx)
        .sort(() => Math.random() - 0.5)
        .slice(0, starterTrees);
      for (const idx of starterIndices) {
        const spot = state.saplingSpots[idx];
        spot.planted = true;
        spot.growth = rand(0.45, 0.9);
        spot.acornDropped = spot.growth >= 0.85;
        spot.needsWater = Math.random() < WATER.wiltChance;
        spot.wiltAt = state.t + Math.floor(rand(WATER.wiltDelayMin, WATER.wiltDelayMax));
        spot.wilted = false;
        spot.wiltBlend = 0;
      }

      state.litterSpots = [];
      for (let i = 0; i < 16; i++) {
        let candidate = null;
        for (let attempt = 0; attempt < 12; attempt++) {
          const pt = { x: rand(80, WORLD.w - 80), y: rand(80, WORLD.h - 80) };
          if (!isInStream(pt, 18)) {
            candidate = pt;
            break;
          }
        }
        if (candidate) {
          state.litterSpots.push({
            x: candidate.x,
            y: candidate.y,
            cleaned: false,
            spreadReadyFrame: 0,
            spreadDone: false,
            variant: Math.random() < 0.5 ? 2 : 3
          });
        }
      }

      state.leaves = Array.from({ length: 24 }, () => ({
        x: rand(0, WORLD.w),
        y: rand(0, WORLD.h),
        speed: rand(0.4, 1.1),
        sway: rand(0.6, 2.2),
        phase: rand(0, Math.PI * 2)
      }));

      state.flowers = [];
      state.grassTufts = [];
      state.ferns = [];
      state.bushes = [];
      state.meadowGrass = [];
      state.animals = [];
      spawnAnimal("rabbit", { minX: 140, maxX: WORLD.w - 140, minY: 180, maxY: WORLD.h - 80, padding: 18 });
      state.fireflies = [];
    }

    function resetGame() {
      state.won = false;
      state.t = 0;
      state.ecoScore = 5;
      state.celebrationFrames = 0;
      state.acorns = 0;
      state.waterCarried = false;
      state.planted = 0;
      state.cleaned = 0;
      state.surprises = [];
      state.recentImpacts = [];
      state.eventLog = [];
      state.stats.surprisesTriggered = 0;
      state.stats.flowerSpreadEvents = 0;
      state.stats.treeAcornDrops = 0;
      state.stats.wildlifeFromSurprises = 0;
      state.stats.acornsCollected = 0;
      state.stats.treesWatered = 0;
      state.stats.animalsNamed = 0;
      state.lastMovementInputFrame = state.t;
      state.lastWiltMessageFrame = -9999;
      state.noAcornHintUntil = 0;
      state.basicActionHintsShown.acorn = false;
      state.basicActionHintsShown.plant = false;
      state.basicActionHintsShown.clean = false;
      state.basicActionHintsShown.waterFill = false;
      state.basicActionHintsShown.waterTree = false;
      state.player.x = 140;
      state.player.y = 620;
      state.player.step = 0;
      state.player.moving = false;
      state.questIndex = 0;
      state.lastQuestNoticeId = null;
      state.questUnlocks.afterClean = false;
      state.questUnlocks.afterAcorn = false;
      state.questUnlocks.afterPlant = false;
      state.questUnlocks.afterWilt = false;
      state.campsiteItems = [];
      state.buildMode = null;
      state.trash.nextSpawnFrame = state.t + Math.floor(rand(60 * 35, 60 * 55));
      state.trash.introShown = false;
      state.trash.raccoonIntroShown = false;
      state.nextFlowerSpreadFrame = 0;
      state.butterflyBurstDone = false;
      state.butterflyBurstPending = false;
      state.nextRareAnimalFrame = 0;
      state.nextWiltAllowedFrame = 0;
      state.notebookObsBadgeUntil = 0;
      state.notebookHistory = [];
      state.notebookHistoryIndex = -1;
      state.stream = null;
      spawnWorld();
      scheduleNextRareWildlife();
      state.ferns = [];
      state.bushes = [];
      state.meadowGrass = [];
      setBuildMode(null);
      setInspectCard("Nature Notebook", "-", "Interesting facts appear here.", null);
      setMessage("New restoration day! Clean and plant to bring the forest back to life.");
      logImpact("Playthrough reset.");
      setMenuOpen(false);
      setQuestPanelOpen(state.questPanelOpen);
      updateCamera();
      syncUI();
    }

    function setMessage(text) {
      ui.message.textContent = text;
      renderMessageLog();
    }

    function setBasicActionMessageOnce(key, text) {
      if (!state.basicActionHintsShown[key]) {
        state.basicActionHintsShown[key] = true;
        setMessage(text);
      }
    }

    function renderMessageLog() {
      const recent = state.recentImpacts.slice(0, 5);
      const latest = recent.length ? recent[0] : ui.message.textContent;
      const history = recent.slice(1).filter((line) => line !== latest);
      ui.messageHistory.textContent = history.length ? history.join("\n") : "No older events.";
      if (latest && latest !== ui.message.textContent) {
        ui.message.textContent = latest;
      }
    }

    function updateMessageReadability() {
      const daylight = getDaylightLevel();
      const night = 1 - daylight;
      const r = Math.round(28 * daylight + 236 * night);
      const g = Math.round(58 * daylight + 246 * night);
      const b = Math.round(38 * daylight + 240 * night);
      ui.floatingMessage.style.setProperty("--msg-rgb", r + ", " + g + ", " + b);
      ui.floatingMessage.style.setProperty("--msg-shadow-dark-a", (0.5 + night * 0.26).toFixed(3));
      ui.floatingMessage.style.setProperty("--msg-shadow-light-a", (0.18 + daylight * 0.52).toFixed(3));
      ui.floatingMessage.style.setProperty("--msg-outline-a", (0.36 + night * 0.28).toFixed(3));
      ui.questWidget.style.setProperty("--msg-rgb", r + ", " + g + ", " + b);
      ui.questWidget.style.setProperty("--msg-shadow-dark-a", (0.5 + night * 0.26).toFixed(3));
      ui.questWidget.style.setProperty("--msg-shadow-light-a", (0.18 + daylight * 0.52).toFixed(3));
      ui.questWidget.style.setProperty("--msg-outline-a", (0.36 + night * 0.28).toFixed(3));
    }

    function renderAcornStack() {
      const count = Math.max(0, state.acorns);
      ui.acornStack.innerHTML = "";
      ui.acornStack.setAttribute("aria-label", "Acorns: " + count);
      ui.acornStack.title = "Acorns: " + count;
      ui.acornPlaceholder.hidden = count > 0;
      if (count === 0) return;
      const visibleCount = Math.min(count, 26);
      const spacing = clamp(10 - visibleCount * 0.24, 2.4, 8.8);
      const totalW = 11 + (visibleCount - 1) * spacing;
      const left = Math.max(0, (72 - totalW) * 0.5);
      for (let i = 0; i < visibleCount; i++) {
        const chip = document.createElement("span");
        chip.className = "acorn-chip";
        chip.style.left = (left + i * spacing).toFixed(1) + "px";
        chip.style.zIndex = String(i + 1);
        const angle = ((i % 3) - 1) * 4;
        chip.style.transform = "rotate(" + angle + "deg)";
        ui.acornStack.appendChild(chip);
      }
    }

    function renderCleanedStack() {
      const count = Math.max(0, state.cleaned);
      ui.cleanedStack.innerHTML = "";
      ui.cleanedStack.setAttribute("aria-label", "Trash collected: " + count);
      ui.cleanedPlaceholder.hidden = count > 0;
      if (count === 0) return;
      const visibleCount = Math.min(count, 40);
      const spacing = clamp(8 - visibleCount * 0.12, 1.6, 6);
      const totalW = 8 + (visibleCount - 1) * spacing;
      const left = Math.max(0, Math.min(36, (72 - totalW) * 0.5));
      const palette = ["#ff7aa2", "#56c2ff", "#f7d36f"];
      for (let i = 0; i < visibleCount; i++) {
        const chip = document.createElement("span");
        chip.className = "trash-chip";
        chip.style.left = (left + i * spacing).toFixed(1) + "px";
        chip.style.zIndex = String(i + 1);
        chip.style.background = palette[i % palette.length];
        chip.style.transform = "rotate(" + (((i % 5) - 2) * 4) + "deg)";
        ui.cleanedStack.appendChild(chip);
      }
    }

    function serializeState() {
      return {
        version: 1,
        t: state.t,
        ecoScore: state.ecoScore,
        celebrationFrames: state.celebrationFrames,
        acorns: state.acorns,
        waterCarried: state.waterCarried,
        planted: state.planted,
        cleaned: state.cleaned,
        player: state.player,
        acornNodes: state.acornNodes,
        saplingSpots: state.saplingSpots,
        litterSpots: state.litterSpots,
        puddles: state.puddles,
        leaves: state.leaves,
        flowers: state.flowers,
        grassTufts: state.grassTufts,
        ferns: state.ferns,
        bushes: state.bushes,
        meadowGrass: state.meadowGrass,
        animals: state.animals,
        fireflies: state.fireflies,
        stream: state.stream,
        surprises: state.surprises,
        recentImpacts: state.recentImpacts,
        eventLog: state.eventLog,
        basicActionHintsShown: state.basicActionHintsShown,
        stats: state.stats,
        questIndex: state.questIndex,
        questUnlocks: state.questUnlocks,
        campsiteItems: state.campsiteItems,
        buildMode: state.buildMode,
        trash: state.trash,
        nextFlowerSpreadFrame: state.nextFlowerSpreadFrame,
        butterflyBurstDone: state.butterflyBurstDone,
        butterflyBurstPending: state.butterflyBurstPending,
        nextRareAnimalFrame: state.nextRareAnimalFrame,
        nextWiltAllowedFrame: state.nextWiltAllowedFrame,
        observationLedger: state.observationLedger,
        playerName: state.playerName,
        bestScore: state.bestScore,
        easyMode: state.easyMode,
        noAcornHintUntil: state.noAcornHintUntil
      };
    }

    function applySavedState(save) {
      if (!save) return false;
      state.t = save.t || 0;
      state.ecoScore = save.ecoScore ?? 5;
      state.celebrationFrames = save.celebrationFrames || 0;
      state.acorns = save.acorns || 0;
      state.waterCarried = Boolean(save.waterCarried);
      state.planted = save.planted || 0;
      state.cleaned = save.cleaned || 0;
      state.player = Object.assign(state.player, save.player || {});
      state.acornNodes = save.acornNodes || [];
      state.saplingSpots = save.saplingSpots || [];
      for (const spot of state.saplingSpots) {
        if (typeof spot.customName !== "string") spot.customName = "";
        if (typeof spot.wiltBlend !== "number") spot.wiltBlend = spot.wilted ? 1 : 0;
        if (typeof spot.lastWateredAt !== "number") spot.lastWateredAt = -999999;
      }
      state.litterSpots = save.litterSpots || [];
      state.puddles = save.puddles || [];
      state.leaves = save.leaves || [];
      state.flowers = save.flowers || [];
      state.grassTufts = save.grassTufts || [];
      state.ferns = save.ferns || [];
      state.bushes = save.bushes || [];
      state.meadowGrass = save.meadowGrass || [];
      state.animals = save.animals || [];
      for (const animal of state.animals) {
        if (typeof animal.customName !== "string") animal.customName = "";
        if (typeof animal.everNamed !== "boolean") animal.everNamed = animal.customName.trim().length > 0;
        if (animal.type === "owl") {
          if (!animal.glideTarget || typeof animal.glideTarget.x !== "number" || typeof animal.glideTarget.y !== "number") {
            animal.glideTarget = { x: animal.x, y: animal.y };
          }
          if (typeof animal.nextGlideRetargetFrame !== "number") {
            animal.nextGlideRetargetFrame = state.t + Math.floor(rand(60 * 4, 60 * 8));
          }
        }
      }
      for (const animal of state.animals) {
        if (animal.type === "raccoon" && animal.nextTrashDropFrame == null) {
          animal.nextTrashDropFrame = state.t + Math.floor(rand(60 * 90, 60 * 240));
        }
      }
      state.fireflies = save.fireflies || [];
      for (const firefly of state.fireflies) {
        if (typeof firefly.alpha !== "number") firefly.alpha = 0;
        if (typeof firefly.visibleTarget !== "boolean") firefly.visibleTarget = false;
        if (typeof firefly.fadeDelay !== "number") firefly.fadeDelay = 0;
      }
      state.stream = save.stream || null;
      if (!state.stream) {
        state.stream = createStream();
      } else {
        if (!Array.isArray(state.stream.points) || state.stream.points.length < 2) {
          if (state.stream.start && state.stream.end) {
            const migratedPoints = [state.stream.start];
            if (state.stream.mid1) migratedPoints.push(state.stream.mid1);
            if (state.stream.mid2) migratedPoints.push(state.stream.mid2);
            if (state.stream.mid3) migratedPoints.push(state.stream.mid3);
            migratedPoints.push(state.stream.end);
            state.stream.points = migratedPoints;
          } else {
            state.stream = createStream();
          }
        }
        if (!Array.isArray(state.stream.dashPattern) || state.stream.dashPattern.length < 10) {
          state.stream.dashPattern = makeStreamDashPattern();
        }
        if (
          !Array.isArray(state.stream.flowMarks) ||
          state.stream.flowMarks.length < 8 ||
          state.stream.flowMarksVersion !== 2
        ) {
          state.stream.flowMarks = makeStreamFlowMarks();
          state.stream.flowMarksVersion = 2;
        }
        if (typeof state.stream.width !== "number") {
          state.stream.width = rand(24, 32);
        }
      }
      state.surprises = save.surprises || [];
      state.recentImpacts = save.recentImpacts || [];
      state.eventLog = save.eventLog || [];
      state.basicActionHintsShown = Object.assign(state.basicActionHintsShown, save.basicActionHintsShown || {});
      state.recentImpacts = state.recentImpacts.map(normalizeLegacyLogLine);
      state.eventLog = state.eventLog.map(normalizeLegacyLogLine);
      state.stats = Object.assign(state.stats, save.stats || {});
      if (!Number.isFinite(state.stats.animalsNamed) || state.stats.animalsNamed < 0) {
        state.stats.animalsNamed = state.animals.filter((animal) => animal.everNamed).length;
      }
      state.questIndex = save.questIndex || 0;
      state.questUnlocks = Object.assign(state.questUnlocks, save.questUnlocks || {});
      state.campsiteItems = save.campsiteItems || [];
      state.buildMode = save.buildMode || null;
      state.trash = Object.assign(state.trash, save.trash || {});
      state.nextFlowerSpreadFrame = save.nextFlowerSpreadFrame || 0;
      state.butterflyBurstDone = Boolean(save.butterflyBurstDone);
      state.butterflyBurstPending = Boolean(save.butterflyBurstPending);
      state.nextRareAnimalFrame = save.nextRareAnimalFrame || 0;
      state.nextWiltAllowedFrame = save.nextWiltAllowedFrame || 0;
      state.notebookHistory = [];
      state.notebookHistoryIndex = -1;
      state.observationLedger = Object.assign({ used: {}, serial: 1 }, save.observationLedger || {});
      if (!state.observationLedger.used || typeof state.observationLedger.used !== "object") {
        state.observationLedger.used = {};
      }
      if (!Number.isFinite(state.observationLedger.serial) || state.observationLedger.serial < 1) {
        state.observationLedger.serial = 1;
      }
      state.playerName = save.playerName || "";
      state.bestScore = save.bestScore || state.bestScore;
      state.easyMode = Boolean(save.easyMode);
      state.noAcornHintUntil = save.noAcornHintUntil || 0;
      // Rebuild observation ledger from loaded entities so new notes stay globally unique.
      const registerUsedNotes = (entity) => {
        if (!entity) return;
        if (Array.isArray(entity.observationPlan)) {
          for (const line of entity.observationPlan) {
            if (typeof line === "string" && line) state.observationLedger.used[line] = true;
          }
        }
        if (Array.isArray(entity.observations)) {
          for (const line of entity.observations) {
            if (typeof line === "string" && line) state.observationLedger.used[line] = true;
          }
        }
      };
      for (const spot of state.saplingSpots) registerUsedNotes(spot);
      for (const animal of state.animals) registerUsedNotes(animal);
      normalizeDecorationSpawnTimes();
      sanitizeSaplingSpotsAgainstWater();
      syncNameInputs();
      if (!state.trash.nextSpawnFrame || state.trash.nextSpawnFrame <= state.t) {
        scheduleNextTrashSpawn();
      }
      if (!state.nextRareAnimalFrame || state.nextRareAnimalFrame <= state.t) {
        scheduleNextRareWildlife();
      }
      setBuildMode(state.buildMode);
      setQuestPanelOpen(state.questPanelOpen);
      setInspectCard("Nature Notebook", "-", "Interesting facts appear here.", null);
      updateCamera();
      syncUI();
      return true;
    }

    function loadSavedGame() {
      const raw = localStorage.getItem("forest-save");
      if (!raw) return false;
      try {
        const save = JSON.parse(raw);
        return applySavedState(save);
      } catch (err) {
        console.warn("Failed to load save:", err);
        return false;
      }
    }

    function saveGameNow() {
      if (!state.saveLoaded) return;
      const payload = serializeState();
      try {
        localStorage.setItem("forest-save", JSON.stringify(payload));
      } catch (err) {
        console.warn("Failed to save game:", err);
      }
    }

    function scheduleSave() {
      if (!state.saveLoaded) return;
      if (state.saveTimer) return;
      state.saveTimer = setTimeout(() => {
        state.saveTimer = null;
        saveGameNow();
      }, 2000);
    }

    function setQuestPanelOpen(open) {
      state.questPanelOpen = Boolean(open);
      ui.questPanel.classList.toggle("expanded", state.questPanelOpen);
      ui.questToggle.textContent = state.questPanelOpen ? "Less" : "More";
      ui.questToggle.setAttribute("aria-expanded", state.questPanelOpen ? "true" : "false");
      localStorage.setItem("forest-quest-panel", state.questPanelOpen ? "open" : "closed");
    }

    const CAMPSITE_CATALOG = [
      {
        id: "tent",
        name: "Canvas Tent",
        detail: "A cozy shelter for your ranger.",
        unlockHint: "Unlock by planting 2 trees.",
        unlocked: () => state.planted >= 2
      },
      {
        id: "firepit",
        name: "Fire Pit",
        detail: "A safe place for warmth and stories.",
        unlockHint: "Unlock by cleaning 4 litter spots.",
        unlocked: () => state.cleaned >= 4
      },
      {
        id: "log-seats",
        name: "Log Seats",
        detail: "Simple seating for quiet moments.",
        unlockHint: "Unlock by planting 6 trees.",
        unlocked: () => state.planted >= 6
      },
      {
        id: "lantern",
        name: "Lantern",
        detail: "A soft glow for evening walks.",
        unlockHint: "Unlock by reaching 25% Eco Health.",
        unlocked: () => state.ecoScore >= 25
      }
    ];

    const CAMPSITE_LOOKUP = Object.fromEntries(CAMPSITE_CATALOG.map((item) => [item.id, item]));

    function setBuildMode(id) {
      state.buildMode = id;
      if (id) {
        ui.campsiteMode.hidden = false;
        const entry = CAMPSITE_LOOKUP[id];
        if (entry) {
          ui.campsiteMode.textContent = "Placement mode: click the map to place " + entry.name + ".";
        }
      } else {
        ui.campsiteMode.hidden = true;
      }
      renderCampsiteList();
      scheduleSave();
    }

    function renderCampsiteList() {
      ui.campsiteList.innerHTML = CAMPSITE_CATALOG.map((item) => {
        const unlocked = item.unlocked();
        const active = state.buildMode === item.id;
        const label = active ? "Cancel Placement" : "Place";
        return (
          "<button class=\"campsite-item\" type=\"button\" data-item-id=\"" + item.id + "\" " + (unlocked ? "" : "disabled") + ">" +
            "<strong>" + item.name + "</strong>" +
            "<span>" + item.detail + "</span>" +
            "<span>" + (unlocked ? label : item.unlockHint) + "</span>" +
          "</button>"
        );
      }).join("");
    }

    function canPlaceCampsiteItem(point) {
      if (!point) return false;
      if (point.x < 40 || point.x > WORLD.w - 40 || point.y < 40 || point.y > WORLD.h - 40) return false;
      for (const puddle of state.puddles) {
        if (distance(point, puddle) < puddle.r + 26) return false;
      }
      if (isInStream(point, 24)) return false;
      return true;
    }

    function placeCampsiteItem(point) {
      if (!state.buildMode) return false;
      if (!canPlaceCampsiteItem(point)) {
        setMessage("Pick a dry, open spot for your campsite item.");
        return false;
      }
      const entry = CAMPSITE_LOOKUP[state.buildMode];
      if (!entry) return false;
      state.campsiteItems.push({
        id: entry.id,
        x: point.x,
        y: point.y,
        placedAt: state.t
      });
      setMessage(entry.name + " placed!");
      setBuildMode(null);
      return true;
    }

    function getQuestProgress(quest) {
      if (!quest || !quest.goal) return 0;
      switch (quest.goal.type) {
        case "clean":
          return Math.min(state.cleaned, quest.goal.target);
        case "plant":
          return Math.min(state.planted, quest.goal.target);
        case "eco":
          return Math.min(Math.round(state.ecoScore), quest.goal.target);
        case "acorn":
          return Math.min(state.stats.acornsCollected, quest.goal.target);
        case "water":
          return Math.min(state.stats.treesWatered, quest.goal.target);
        case "nameAnimal":
          return Math.min(state.stats.animalsNamed, quest.goal.target);
        default:
          return 0;
      }
    }

    function isQuestComplete(quest) {
      return getQuestProgress(quest) >= quest.goal.target;
    }

    function isQuestUnlocked(quest) {
      if (!quest || !quest.unlock || quest.unlock === "start") return true;
      switch (quest.unlock) {
        case "afterClean":
          return state.questUnlocks.afterClean;
        case "afterAcorn":
          return state.questUnlocks.afterAcorn;
        case "afterPlant":
          return state.questUnlocks.afterPlant;
        case "afterWilt":
          return state.questUnlocks.afterWilt;
        default:
          return true;
      }
    }

    function maybeAdvanceQuest() {
      const current = QUESTS[state.questIndex];
      if (!current) return;
      if (!isQuestUnlocked(current)) return;
      if (isQuestComplete(current)) {
        state.questIndex += 1;
        state.lastQuestNoticeId = current.id;
      }
    }

    function renderQuestList() {
      ui.questList.innerHTML = QUESTS.map((quest) => {
        const progress = getQuestProgress(quest);
        const complete = isQuestComplete(quest);
        const unlocked = isQuestUnlocked(quest);
        const status = !unlocked ? "locked" : (complete ? "done" : progress + "/" + quest.goal.target);
        const shortDetail = (quest.short || "").replace(/\.$/, "");
        return (
          "<div class=\"quest-item" + (complete ? " done" : "") + "\">" +
            "<div class=\"quest-head\">" +
              "<span>" + quest.title + " - " + status + " - " + shortDetail + "</span>" +
            "</div>" +
          "</div>"
        );
      }).join("");
    }

    function renderQuestWidget() {
      ui.questWidgetToggle.hidden = false;
      ui.questWidgetToggle.textContent = state.questWidgetExpanded ? "â–´" : "â–¾";
      ui.questWidgetToggle.setAttribute("aria-expanded", state.questWidgetExpanded ? "true" : "false");
      const visibleQuests = QUESTS.filter((quest) => isQuestUnlocked(quest) && !isQuestComplete(quest));
      if (!visibleQuests.length) {
        if (state.questWidgetExpanded) {
          ui.questWidgetList.innerHTML = "<div class=\"quest-widget-item done\">All quests complete.</div>";
        } else {
          ui.questWidgetList.innerHTML = "";
        }
        return;
      }

      const maxDefault = 3;
      const maxShown = state.questWidgetExpanded ? visibleQuests.length : Math.min(maxDefault, visibleQuests.length);
      const subset = visibleQuests.slice(0, maxShown);
      let html = subset.map((quest) => {
        const progress = getQuestProgress(quest);
        const complete = isQuestComplete(quest);
        const status = complete ? "done" : progress + "/" + quest.goal.target;
        return (
          "<div class=\"quest-widget-item" + (complete ? " done" : "") + "\">" +
            quest.title + " - " + status +
          "</div>"
        );
      }).join("");

      const hasMore = visibleQuests.length > maxDefault;
      if (hasMore && !state.questWidgetExpanded) {
        html += "<div class=\"quest-widget-more\">...</div>";
      }
      ui.questWidgetList.innerHTML = html;
      ui.questWidgetToggle.hidden = !hasMore && !state.questWidgetExpanded;
    }

    function openQuestPopup(quest) {
      if (!quest) return;
      const progress = getQuestProgress(quest);
      ui.questPopupTitle.textContent = quest.title;
      ui.questPopupBody.textContent = quest.detail;
      ui.questPopupProgress.textContent = "Progress: " + progress + "/" + quest.goal.target + " " + quest.goal.label;
      ui.questPopup.classList.add("open");
      ui.questPopup.setAttribute("aria-hidden", "false");
    }

    function closeQuestPopup() {
      ui.questPopup.classList.remove("open");
      ui.questPopup.setAttribute("aria-hidden", "true");
    }

    function syncUI() {
      renderAcornStack();
      renderCleanedStack();
      ui.water.textContent = state.waterCarried ? "Full" : "Empty";
      ui.waterIcon.classList.toggle("full", state.waterCarried);
      ui.trees.textContent = state.planted;
      ui.best.textContent = state.bestScore;
      ui.ecoHud.textContent = "Eco " + Math.round(state.ecoScore) + "%";
      ui.wildlifeHud.textContent = "Wildlife " + getVisibleAnimals().length;
      ui.notebookTab.classList.toggle("hint-pulse", state.t < state.notebookHintUntil && !state.inspectExpanded);
      renderMessageLog();
      maybeAdvanceQuest();
      renderQuestList();
      renderQuestWidget();
      renderCampsiteList();
      if (state.inspectTarget) {
        const unlocked = unlockObservations(state.inspectTarget);
        if (unlocked) {
          renderInspectObservations();
        }
      }
      scheduleSave();
    }

    function playerMove() {
      let dx = 0;
      let dy = 0;
      let speedScale = 1;

      if (state.touch.active) {
        dx = state.touch.dx;
        dy = state.touch.dy;
        speedScale = clamp(Math.hypot(dx, dy), 0, 1);
      }

      if (state.keys.has("ArrowLeft") || state.keys.has("a")) dx -= 1;
      if (state.keys.has("ArrowRight") || state.keys.has("d")) dx += 1;
      if (state.keys.has("ArrowUp") || state.keys.has("w")) dy -= 1;
      if (state.keys.has("ArrowDown") || state.keys.has("s")) dy += 1;
      if (state.keys.size) {
        speedScale = 1;
      }

      let moved = false;
      if (dx !== 0 || dy !== 0) {
        moved = movePlayerByVector(dx, dy, speedScale);
        state.lastMovementInputFrame = state.t;
      } else if (state.mouseWorld && state.t - state.lastMovementInputFrame > 600) {
        const toMouseX = state.mouseWorld.x - state.player.x;
        const toMouseY = state.mouseWorld.y - state.player.y;
        const dist = Math.hypot(toMouseX, toMouseY);
        if (dist > 10) {
          const ramp = clamp((state.t - state.lastMovementInputFrame - 600) / 180, 0, 1);
          moved = movePlayerByVector(toMouseX / dist, toMouseY / dist, 0.22 + ramp * 0.5);
        }
      }

      state.player.moving = moved;
      if (moved) {
        state.player.step = (state.player.step || 0) + 0.22;
      }
      state.player.x = clamp(state.player.x, state.player.r, WORLD.w - state.player.r);
      state.player.y = clamp(state.player.y, state.player.r, WORLD.h - state.player.r);
    }

    function movePlayerByVector(dx, dy, speedScale) {
      const mag = Math.hypot(dx, dy);
      if (mag === 0) return false;

      dx /= mag;
      dy /= mag;
      let speed = state.player.speed * speedScale;
      for (const puddle of state.puddles) {
        if (distance(state.player, puddle) < puddle.r + state.player.r * 0.4) {
          speed *= 0.52;
          break;
        }
      }

      const oldX = state.player.x;
      const oldY = state.player.y;
      state.player.x += dx * speed;
      state.player.y += dy * speed;
      state.player.facing = dx < -0.02 ? -1 : dx > 0.02 ? 1 : state.player.facing;
      return Math.hypot(state.player.x - oldX, state.player.y - oldY) > 0.01;
    }

    function updateAcorns() {
      for (const acorn of state.acornNodes) {
        if (!acorn.active) continue;
        acorn.pulse += 0.05;
        if (distance(state.player, acorn) < state.player.r + 12) {
          acorn.active = false;
      state.acorns += 1;
      state.stats.acornsCollected += 1;
      state.questUnlocks.afterAcorn = true;
      setBasicActionMessageOnce("acorn", "Acorn found! You can use it to plant a tree.");
        }
      }

      if (state.acornNodes.every((a) => !a.active)) {
        const refill = state.acornNodes.slice(0, 10);
        for (const a of refill) {
          let pt = null;
          for (let attempt = 0; attempt < 12; attempt++) {
            const cand = { x: rand(70, WORLD.w - 70), y: rand(70, WORLD.h - 70) };
            if (!isInWater(cand, 10)) {
              pt = cand;
              break;
            }
          }
          if (!pt) continue;
          a.active = true;
          a.x = pt.x;
          a.y = pt.y;
        }
      }
    }

    function updateLeaves() {
      for (const leaf of state.leaves) {
        leaf.y += leaf.speed;
        leaf.x += Math.sin(state.t * 0.03 + leaf.phase) * leaf.sway;
        if (leaf.y > WORLD.h + 10) {
          leaf.y = -10;
          leaf.x = rand(0, WORLD.w);
        }
      }
    }

    function interact() {
      if (state.waterCarried) {
        for (const spot of state.saplingSpots) {
          if (spot.wilted && distance(state.player, spot) < 32) {
            attemptWaterPlant(spot);
            return;
          }
        }
      } else {
        const pond = pondWithin(state.player, 18);
        if (pond) {
          attemptCollectWater(pond, "pond");
          return;
        }
        if (streamWithin(state.player, 16)) {
          attemptCollectWater(null, "stream");
          return;
        }
      }

      for (const spot of state.saplingSpots) {
        if (!spot.planted && distance(state.player, spot) < 28) {
          attemptPlant(spot);
          return;
        }
      }

      for (const spot of state.litterSpots) {
        if (!spot.cleaned && distance(state.player, spot) < 28) {
          attemptCleanup(spot);
          return;
        }
      }

      setMessage("Try standing near a ðŸŒ±, ðŸ§º, or a pond, then press Space.");
    }

    function updateEcoSystem() {
      for (const spot of state.saplingSpots) {
        if (spot.planted) {
          if (typeof spot.wiltBlend !== "number") spot.wiltBlend = spot.wilted ? 1 : 0;
          const wiltTarget = spot.wilted ? 1 : 0;
          const wiltStep = 1 / Math.max(1, WATER.transitionFrames);
          if (spot.wiltBlend < wiltTarget) {
            spot.wiltBlend = clamp(spot.wiltBlend + wiltStep, 0, 1);
          } else if (spot.wiltBlend > wiltTarget) {
            spot.wiltBlend = clamp(spot.wiltBlend - wiltStep, 0, 1);
          }
          if (!spot.wilted) {
            spot.growth = clamp((spot.growth || 0.04) + 0.00055, 0.04, 1);
          }
          if (spot.growth >= 0.985 && !spot.acornDropped) {
            spot.acornDropped = true;
            const growth = spot.growth || 0.04;
            const trunk = (6 + growth * 12) * 2;
            const baseY = spot.y + 16 + trunk + rand(6, 16);
            let acornPt = null;
            for (let attempt = 0; attempt < 8; attempt++) {
              const cand = {
                x: clamp(spot.x + rand(-12, 12), 30, WORLD.w - 30),
                y: clamp(baseY + rand(-4, 6), 30, WORLD.h - 30)
              };
              if (!isInWater(cand, 10)) {
                acornPt = cand;
                break;
              }
            }
            if (acornPt) {
              state.acornNodes.push({
                x: acornPt.x,
                y: acornPt.y,
                active: true,
                pulse: rand(0, Math.PI * 2)
              });
            }
            state.stats.treeAcornDrops += 1;
            logImpact("A mature " + spot.treeType + " dropped an acorn.");
          }

          if (
            !spot.wilted &&
            spot.needsWater &&
            state.t >= spot.wiltAt &&
            state.t >= state.nextWiltAllowedFrame &&
            countWiltedPlants() < WATER.maxWilted
          ) {
            spot.wilted = true;
            state.questUnlocks.afterWilt = true;
            if (state.t - state.lastWiltMessageFrame > 60 * 20) {
              setMessage("A young tree is getting thirsty. Refill at a pond, then water it.");
              state.lastWiltMessageFrame = state.t;
            }
            logImpact("A " + spot.treeType + " tree is getting thirsty.");
          }
        }
      }

      for (const flower of state.flowers) {
        flower.growth = clamp(flower.growth + 0.0008, 0.03, 1);
      }

      for (const spot of state.litterSpots) {
        if (spot.cleaned && !spot.spreadDone && state.t >= spot.spreadReadyFrame) {
          spot.spreadDone = true;
          state.stats.flowerSpreadEvents += 1;
          const tinyPatchCount = 2;
          for (let p = 0; p < tinyPatchCount; p++) {
            const ang = rand(0, Math.PI * 2);
            const dist = rand(24, 54);
            const cx = clamp(spot.x + Math.cos(ang) * dist, 20, WORLD.w - 20);
            const cy = clamp(spot.y + Math.sin(ang) * dist, 20, WORLD.h - 20);
            const flowersInPatch = 2 + Math.floor(rand(0, 2));
            for (let i = 0; i < flowersInPatch; i++) {
              state.flowers.push({
                x: cx + rand(-8, 8),
                y: cy + rand(-8, 8),
                growth: 0.03,
                color: ["#ffd166", "#ff7aa2", "#b5e48c", "#9bf6ff"][Math.floor(rand(0, 4))]
              });
            }
          }
          logImpact("Flowers spread into nearby mini patches.");
        }
      }

      const matureTrees = state.saplingSpots.filter((s) => s.planted && s.growth > 0.65).length;
      const matureFlowers = state.flowers.filter((f) => f.growth > 0.7).length;

      const ecoRaw = state.cleaned * 5 + state.planted * 4 + matureTrees * 2 + matureFlowers * 0.4;
      state.ecoScore = clamp(
        5 + ecoRaw * 0.4,
        5,
        100
      );

      const residentTypes = ["rabbit", "bird", "deer", "fox", "owl", "squirrel", "raccoon"];
      const residentAnimals = state.animals.filter((animal) =>
        residentTypes.includes(animal.type) && animal.ttl === null && !animal.expiring
      );
      const targetResidents = clamp(1 + Math.floor(state.ecoScore / 18), 1, residentTypes.length);
      for (let i = 0; i < residentTypes.length && residentAnimals.length < targetResidents; i++) {
        const type = residentTypes[i];
        const alreadyPresent = residentAnimals.some((animal) => animal.type === type);
        if (alreadyPresent) continue;
        const spawned = spawnAnimal(type, { minX: 140, maxX: WORLD.w - 140, minY: 160, maxY: WORLD.h - 80, padding: 18 });
        if (spawned) {
          residentAnimals.push(spawned);
          setMessage("Wildlife is returning to the forest!");
        }
      }
    }

    function attemptPlant(spot) {
      if (state.acorns < 1) {
        setMessage("Planting needs 1 acorn. Gather one first.");
        state.noAcornHintUntil = state.t + 70;
        return;
      }
      if (spot.planted) return;

      spot.planted = true;
      spot.growth = 0.04;
      spot.acornDropped = false;
      spot.wilted = false;
      spot.wiltBlend = 0;
      spot.needsWater = Math.random() < WATER.wiltChance;
      spot.wiltAt = state.t + Math.floor(rand(WATER.wiltDelayMin, WATER.wiltDelayMax));
      spot.lastWateredAt = -999999;
      state.acorns -= 1;
      state.planted += 1;
      state.ecoScore += 3;
      state.questUnlocks.afterPlant = true;
      setBasicActionMessageOnce("plant", "Tree planted. It will grow over time.");
      logImpact("Planted " + spot.treeType + " tree.");

      scheduleSurprise("pollinator-arrival", Math.floor(rand(60 * 25, 60 * 65)), {
        x: spot.x,
        y: spot.y,
        treeType: spot.treeType
      });
      scheduleSurprise("grass-tuft", Math.floor(rand(60 * 70, 60 * 125)), {
        x: spot.x,
        y: spot.y
      });
    }

    function attemptCleanup(spot) {
      if (spot.cleaned) return;
      spot.cleaned = true;
      state.cleaned += 1;
      state.ecoScore += 5;
      state.questUnlocks.afterClean = true;
      spot.spreadReadyFrame = state.t + Math.floor(rand(60 * 60, 60 * 120));
      spot.spreadDone = false;

      const newFlowers = 1 + Math.floor(rand(0, 3));
      for (let i = 0; i < newFlowers; i++) {
        let newPt = null;
        for (let attempt = 0; attempt < 8; attempt++) {
          const cand = { x: spot.x + rand(-13, 13), y: spot.y + rand(-10, 10) };
          if (!isInWater(cand, 8)) {
            newPt = cand;
            break;
          }
        }
        if (!newPt) continue;
        state.flowers.push({
          x: newPt.x,
          y: newPt.y,
          growth: 0.03,
          color: ["#ffd166", "#ff7aa2", "#b5e48c", "#9bf6ff"][Math.floor(rand(0, 4))]
        });
      }

      setBasicActionMessageOnce("clean", "Litter cleaned. New flowers are starting to bloom here.");
      logImpact("Cleaned litter.");

      scheduleSurprise("soil-recovery", Math.floor(rand(60 * 35, 60 * 80)), {
        x: spot.x,
        y: spot.y
      });

      const nearPond = nearestPond(spot, 170);
      if (nearPond) {
        scheduleSurprise("fish-return", Math.floor(rand(60 * 45, 60 * 95)), {
          x: nearPond.x,
          y: nearPond.y
        });
      }
    }

    function attemptCollectAcorn(acorn) {
      if (!acorn.active) return;
      acorn.active = false;
      state.acorns += 1;
      state.stats.acornsCollected += 1;
      state.questUnlocks.afterAcorn = true;
      setBasicActionMessageOnce("acorn", "Acorn collected.");
    }

    function attemptCollectWater(puddle, sourceLabel = "pond") {
      if (state.waterCarried) {
        setMessage("Your water is already full.");
        return;
      }
      state.waterCarried = true;
      setBasicActionMessageOnce("waterFill", "Water collected from the " + sourceLabel + ". Find a thirsty tree.");
      logImpact("Collected water from a " + sourceLabel + ".");
    }

    function attemptWaterPlant(spot) {
      if (!spot.planted) return;
      if (!spot.wilted) {
        setMessage("This tree looks healthy.");
        return;
      }
      if (!state.waterCarried) {
        setMessage("You need water first. Visit a pond to refill.");
        return;
      }
      spot.wilted = false;
      spot.needsWater = false;
      spot.lastWateredAt = state.t;
      spot.growth = clamp((spot.growth || 0.04) + 0.05, 0.04, 1);
      state.nextWiltAllowedFrame = Math.max(state.nextWiltAllowedFrame, state.t + WATER.postWaterGraceFrames);
      state.waterCarried = false;
      state.stats.treesWatered += 1;
      state.ecoScore = clamp(state.ecoScore + 1, 5, 100);
      setBasicActionMessageOnce("waterTree", "You watered the tree. Itâ€™s perking up!");
      logImpact("Watered " + spot.treeType + " tree.");
    }

    function getCanvasPoint(event) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const screenX = (event.clientX - rect.left) * scaleX;
      const screenY = (event.clientY - rect.top) * scaleY;
      const zoom = state.camera.zoom || 1;
      return {
        x: screenX / zoom + state.camera.x,
        y: screenY / zoom + state.camera.y
      };
    }

    function findInteractiveTarget(point) {
      for (const animal of getInteractableAnimals()) {
        if (distance(point, animal) <= 18) return { kind: "animal", ref: animal };
      }

      for (const spot of state.saplingSpots) {
        if (!spot.planted && distance(point, spot) <= 24) return { kind: "plant-spot", ref: spot };
        if (spot.planted && distance(point, spot) <= 28) return { kind: "tree", ref: spot };
      }

      for (const spot of state.litterSpots) {
        if (!spot.cleaned && distance(point, spot) <= 24) return { kind: "litter", ref: spot };
      }

      for (const acorn of state.acornNodes) {
        if (acorn.active && distance(point, acorn) <= 16) return { kind: "acorn", ref: acorn };
      }

      for (const puddle of state.puddles) {
        if (distance(point, puddle) <= puddle.r + 8) return { kind: "pond", ref: puddle };
      }

      if (isInStream(point, 12)) return { kind: "stream", ref: point };

      return null;
    }

    function handleCanvasPoint(point) {
      const target = findInteractiveTarget(point);
      if (!target) return;

      if (target.kind === "animal") {
        const animal = target.ref;
        setInspectCard(
          "Animal Notes",
          animal.type.charAt(0).toUpperCase() + animal.type.slice(1),
          animal.fact,
          animal,
          true
        );
        return;
      }

      if (target.kind === "plant-spot") {
        attemptPlant(target.ref);
        return;
      }

      if (target.kind === "tree") {
        const spot = target.ref;
        if (spot.wilted) {
          attemptWaterPlant(spot);
          return;
        }
        setInspectCard("Tree Notes", spot.treeType + " Tree", spot.treeFact, spot, true);
        return;
      }

      if (target.kind === "litter") {
        attemptCleanup(target.ref);
        return;
      }

      if (target.kind === "acorn") {
        attemptCollectAcorn(target.ref);
        return;
      }

      if (target.kind === "pond") {
        attemptCollectWater(target.ref, "pond");
      }

      if (target.kind === "stream") {
        attemptCollectWater(null, "stream");
      }
    }

    function handleCanvasClick(event) {
      const point = getCanvasPoint(event);
      if (state.buildMode) {
        placeCampsiteItem(point);
        return;
      }
      handleCanvasPoint(point);
    }

    function handleCanvasMove(event) {
      const point = getCanvasPoint(event);
      state.mouseWorld = point;
      state.hoverTarget = findInteractiveTarget(point);
      if (state.buildMode) {
        canvas.style.cursor = canPlaceCampsiteItem(point) ? "crosshair" : "not-allowed";
      } else {
        canvas.style.cursor = state.hoverTarget ? "pointer" : "default";
      }
    }

    function clearCanvasHover() {
      state.hoverTarget = null;
      canvas.style.cursor = "default";
    }

    function scheduleNextTrashSpawn() {
      const ecoFactor = clamp(state.ecoScore / 100, 0, 1);
      const baseMin = 60 * 45;
      const baseMax = 60 * 80;
      const bonus = 1 + ecoFactor * 0.45;
      const delay = Math.floor(rand(baseMin * bonus, baseMax * bonus));
      state.trash.nextSpawnFrame = state.t + delay;
    }

    function spawnTrash() {
      const active = state.litterSpots.filter((s) => !s.cleaned).length;
      const maxActive = 10;
      if (active >= maxActive) {
        scheduleNextTrashSpawn();
        return;
      }
      let placed = false;
      for (let i = 0; i < 28; i++) {
        const candidate = {
          x: rand(80, WORLD.w - 80),
          y: rand(80, WORLD.h - 80),
          cleaned: false,
          spreadReadyFrame: 0,
          spreadDone: false,
          variant: Math.random() < 0.5 ? 2 : 3
        };
        if (distance(candidate, state.player) < 120) continue;
        state.litterSpots.push(candidate);
        placed = true;
        break;
      }
      if (placed && !state.trash.introShown) {
        setMessage("Visitors left a bit of litter. Keep the trail tidy!");
        state.trash.introShown = true;
      }
      scheduleNextTrashSpawn();
    }

    function dropRaccoonTrash(raccoon) {
      const active = state.litterSpots.filter((s) => !s.cleaned).length;
      if (active >= 14) return false;
      for (let i = 0; i < 12; i++) {
        const candidate = {
          x: clamp(raccoon.x + rand(-28, 28), 80, WORLD.w - 80),
          y: clamp(raccoon.y + rand(-22, 22), 80, WORLD.h - 80),
          cleaned: false,
          spreadReadyFrame: 0,
          spreadDone: false,
          variant: Math.random() < 0.5 ? 2 : 3
        };
        const overlaps = state.litterSpots.some((spot) => !spot.cleaned && distance(spot, candidate) < 18);
        if (overlaps) continue;
        state.litterSpots.push(candidate);
        return true;
      }
      return false;
    }

    function scheduleNextRareWildlife() {
      const delay = Math.floor(rand(RARE_WILDLIFE.minIntervalFrames, RARE_WILDLIFE.maxIntervalFrames));
      state.nextRareAnimalFrame = state.t + delay;
    }

    function updateRareWildlife() {
      if (!state.nextRareAnimalFrame) {
        scheduleNextRareWildlife();
      }
      const cycle = getCycleInfo();
      if (cycle.isNight) return;
      if (state.t < state.nextRareAnimalFrame) return;

      const activeRare = state.animals.some((animal) =>
        (animal.type === "bear" || animal.type === "moose") && !animal.expiring
      );
      if (activeRare) {
        state.nextRareAnimalFrame = state.t + Math.floor(rand(60 * 60 * 8, 60 * 60 * 14));
        return;
      }

      const type = Math.random() < 0.5 ? "bear" : "moose";
      const ttl = Math.floor(rand(RARE_WILDLIFE.minStayFrames, RARE_WILDLIFE.maxStayFrames));
      const spawned = spawnAnimal(
        type,
        { minX: 150, maxX: WORLD.w - 150, minY: 170, maxY: WORLD.h - 80, padding: 24 },
        { ttl, spawnFade: true }
      );
      scheduleNextRareWildlife();
      if (spawned) {
        logEvent("Triggered rare wildlife: " + type);
        logImpact("Rare wildlife sighting: " + type + ".");
        setMessage("A rare " + type + " was spotted in the forest.");
      }
    }

    function updateTrashSpawns() {
      if (state.trash.nextSpawnFrame === 0) {
        scheduleNextTrashSpawn();
      }
      if (state.t >= state.trash.nextSpawnFrame) {
        spawnTrash();
      }
    }

    function resetJoystick() {
      state.touch.active = false;
      state.touch.pointerId = null;
      state.touch.dx = 0;
      state.touch.dy = 0;
      ui.joystickKnob.style.transform = "translate(-50%, -50%)";
    }

    function setTouchControlsEnabled(enabled) {
      state.touchControlsEnabled = Boolean(enabled);
      localStorage.setItem("forest-touch-controls", state.touchControlsEnabled ? "on" : "off");
      if (!state.touchControlsEnabled) {
        resetJoystick();
      }
      ui.touchControls.classList.toggle("is-hidden", !state.touchControlsEnabled);
      ui.touchModeLabel.textContent = "Touch Controls: " + (state.touchControlsEnabled ? "On" : "Off");
      ui.touchModeToggle.textContent = state.touchControlsEnabled ? "Hide Touch UI" : "Show Touch UI";
    }

    function updateJoystickFromEvent(event) {
      const rect = ui.joystick.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const maxRadius = rect.width * 0.36;
      const rawX = event.clientX - centerX;
      const rawY = event.clientY - centerY;
      const dist = Math.hypot(rawX, rawY);
      const scale = dist > maxRadius ? maxRadius / dist : 1;
      const x = rawX * scale;
      const y = rawY * scale;
      const nx = maxRadius ? x / maxRadius : 0;
      const ny = maxRadius ? y / maxRadius : 0;
      const mag = Math.min(1, Math.hypot(nx, ny));
      const deadzone = 0.12;
      const responseCurve = 2.2;
      if (mag <= deadzone) {
        state.touch.dx = 0;
        state.touch.dy = 0;
      } else {
        const normalized = (mag - deadzone) / (1 - deadzone);
        const eased = Math.pow(normalized, responseCurve);
        const dirScale = eased / (mag || 1);
        state.touch.dx = nx * dirScale;
        state.touch.dy = ny * dirScale;
      }
      ui.joystickKnob.style.transform = "translate(calc(-50% + " + x.toFixed(1) + "px), calc(-50% + " + y.toFixed(1) + "px))";
    }

    function setupMobileControls() {
      ui.joystick.addEventListener("pointerdown", (event) => {
        if (!state.touchControlsEnabled) return;
        state.touch.active = true;
        state.touch.pointerId = event.pointerId;
        ui.joystick.setPointerCapture(event.pointerId);
        updateJoystickFromEvent(event);
        event.preventDefault();
      });

      ui.joystick.addEventListener("pointermove", (event) => {
        if (!state.touchControlsEnabled) return;
        if (!state.touch.active || event.pointerId !== state.touch.pointerId) return;
        updateJoystickFromEvent(event);
        event.preventDefault();
      });

      const endJoystick = (event) => {
        if (!state.touch.active || event.pointerId !== state.touch.pointerId) return;
        try {
          ui.joystick.releasePointerCapture(event.pointerId);
        } catch (_err) {
        }
        resetJoystick();
      };

      ui.joystick.addEventListener("pointerup", endJoystick);
      ui.joystick.addEventListener("pointercancel", endJoystick);

      ui.touchInteract.addEventListener("pointerdown", (event) => {
        if (!state.touchControlsEnabled) return;
        ui.touchInteract.classList.add("active");
        interact();
        event.preventDefault();
      });
      ui.touchInteract.addEventListener("pointerup", () => {
        ui.touchInteract.classList.remove("active");
      });
      ui.touchInteract.addEventListener("pointercancel", () => {
        ui.touchInteract.classList.remove("active");
      });
      ui.touchInteract.addEventListener("click", (event) => {
        event.preventDefault();
      });
    }

    function drawHoverHighlight() {
      if (!state.hoverTarget) return;

      const target = state.hoverTarget;
      const ref = target.ref;
      let radius = 20;

      if (target.kind === "litter" || target.kind === "plant-spot") radius = 24;
      if (target.kind === "tree") radius = 30;
      if (target.kind === "acorn") radius = 16;
      if (target.kind === "pond") radius = ref.r + 6;
      if (target.kind === "stream") radius = 18;

      ctx.save();
      ctx.strokeStyle = "rgba(255, 255, 255, 0.95)";
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 4]);
      ctx.beginPath();
      ctx.arc(ref.x, ref.y, radius + Math.sin(state.t * 0.12) * 1.5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    const MAX_FLOWERS = 120;

    function updateAnimals() {
      const daylight = getDaylightLevel();
      updateBeePopulation();
      if (state.won) ensureButterflies();
      updateRareWildlife();
      const activeBirds = state.animals.filter((animal) => animal.type === "bird" && !animal.expiring);
      if (activeBirds.length > 10) {
        for (let i = 10; i < activeBirds.length; i++) {
          activeBirds[i].expiring = true;
        }
      }
      for (const animal of state.animals) {
        const isDayAnimal = !animal.nightOnly;
        const cycle = getCycleInfo();
        const shouldBeVisible = animal.expiring
          ? false
          : (cycle.isNight ? animal.nightOnly : !animal.nightOnly);
        if (animal.visibleTarget !== shouldBeVisible) {
          animal.visibleTarget = shouldBeVisible;
          animal.fadeDelay = Math.floor(rand(0, 60 * 2));
        }
        if (animal.fadeDelay > 0) {
          animal.fadeDelay -= 1;
        } else {
          const step = 1 / (60 * 2);
          const targetAlpha = animal.visibleTarget ? 1 : 0;
          if (animal.alpha < targetAlpha) {
            animal.alpha = clamp(animal.alpha + step, 0, 1);
          } else if (animal.alpha > targetAlpha) {
            animal.alpha = clamp(animal.alpha - step, 0, 1);
          }
        }
        const movementScale = isDayAnimal
          ? (daylight < 0.14 ? 0.02 : 0.08 + daylight * 0.92)
          : (0.24 + (1 - daylight) * 0.96);

        if (animal.type === "owl") {
          if (!animal.glideTarget) {
            animal.glideTarget = { x: animal.x, y: animal.y };
          }
          const toTarget = {
            x: animal.glideTarget.x - animal.x,
            y: animal.glideTarget.y - animal.y
          };
          const distToTarget = Math.hypot(toTarget.x, toTarget.y);
          if (distToTarget < 28 || state.t >= (animal.nextGlideRetargetFrame || 0)) {
            const angle = rand(0, Math.PI * 2);
            const glideDist = rand(140, 260); // a few tree widths
            animal.glideTarget = {
              x: clamp(animal.x + Math.cos(angle) * glideDist, 60, WORLD.w - 60),
              y: clamp(animal.y + Math.sin(angle) * glideDist, 90, WORLD.h - 60)
            };
            animal.nextGlideRetargetFrame = state.t + Math.floor(rand(60 * 5, 60 * 10));
          }
          const tx = animal.glideTarget.x - animal.x;
          const ty = animal.glideTarget.y - animal.y;
          const td = Math.max(1, Math.hypot(tx, ty));
          animal.vx = clamp(animal.vx * 0.94 + (tx / td) * 0.11, -0.95, 0.95);
          animal.vy = clamp(animal.vy * 0.94 + (ty / td) * 0.09, -0.85, 0.85);
        }

        if (animal.type === "bee") {
          const target = nearestFlower(animal, 140);
          if (target) {
            const dx = target.x - animal.x;
            const dy = target.y - animal.y;
            const dist = Math.max(1, Math.hypot(dx, dy));
            animal.vx = clamp(animal.vx + (dx / dist) * 0.06, -1.8, 1.8);
            animal.vy = clamp(animal.vy + (dy / dist) * 0.045, -1.6, 1.6);
            if (dist < 16) {
              target.growth = clamp(target.growth + 0.0015, 0.03, 1);
              if (
                target.growth > 0.95 &&
                state.flowers.length < MAX_FLOWERS &&
                state.t > state.nextFlowerSpreadFrame &&
                Math.random() < 0.08
              ) {
                let newPt = null;
                for (let attempt = 0; attempt < 8; attempt++) {
                  const cand = {
                    x: clamp(target.x + rand(-16, 16), 20, WORLD.w - 20),
                    y: clamp(target.y + rand(-12, 12), 20, WORLD.h - 20)
                  };
                  if (!isInWater(cand, 8)) {
                    newPt = cand;
                    break;
                  }
                }
                if (newPt) {
                  state.flowers.push({
                    x: newPt.x,
                    y: newPt.y,
                    growth: 0.04,
                    color: target.color
                  });
                }
                state.nextFlowerSpreadFrame = state.t + Math.floor(rand(60 * 10, 60 * 20));
              }
            }
          }
        }

        let typeSpeed = 1;
        if (animal.type === "bee") typeSpeed = 0.72;
        if (animal.type === "bear") typeSpeed = 0.45;
        if (animal.type === "moose") typeSpeed = 0.55;
        if (animal.type === "raccoon") typeSpeed = 0.8;
        if (animal.type === "squirrel") typeSpeed = 1.1;
        if (animal.type === "owl") typeSpeed = 0.95;
        animal.x += animal.vx * movementScale * typeSpeed;
        animal.y += animal.vy * movementScale * typeSpeed;
        if (animal.type === "owl") {
          // Owls drift with a stronger vertical swoop.
          animal.y += Math.sin(state.t * 0.052 + animal.x * 0.012) * 0.46;
        }
        animal.bob += 0.04;

        if (animal.x < 30 || animal.x > WORLD.w - 30) animal.vx *= -1;
        if (animal.y < 70 || animal.y > WORLD.h - 25) animal.vy *= -1;

        const jitterChance = isDayAnimal ? 0.005 + daylight * 0.02 : 0.01 + (1 - daylight) * 0.02;
        if (animal.type === "bee") {
          animal.vx = clamp(animal.vx + rand(-0.09, 0.09), -0.95, 0.95);
          animal.vy = clamp(animal.vy + rand(-0.075, 0.075), -0.85, 0.85);
        }
        if (animal.type === "butterfly") {
          animal.vx = clamp(animal.vx + rand(-0.18, 0.18), -1.4, 1.4);
          animal.vy = clamp(animal.vy + rand(-0.14, 0.14), -1.2, 1.2);
        }
        if (animal.type === "owl") {
          animal.vx = clamp(animal.vx + rand(-0.015, 0.015), -0.95, 0.95);
          animal.vy = clamp(animal.vy + rand(-0.012, 0.012), -0.85, 0.85);
        }
        if (Math.random() < jitterChance && animal.type !== "owl") {
          animal.vx = clamp(animal.vx + rand(-0.2, 0.2), -1.1, 1.1);
          animal.vy = clamp(animal.vy + rand(-0.16, 0.16), -0.9, 0.9);
        }

        if (
          animal.type === "raccoon" &&
          !animal.expiring &&
          !cycle.isNight &&
          animal.nextTrashDropFrame !== null &&
          state.t >= animal.nextTrashDropFrame
        ) {
          const dropped = dropRaccoonTrash(animal);
          animal.nextTrashDropFrame = state.t + Math.floor(rand(60 * 240, 60 * 540));
          if (dropped) {
            logEvent("Raccoon dropped trash");
            if (!state.trash.raccoonIntroShown) {
              setMessage("A raccoon made a little mess nearby.");
              state.trash.raccoonIntroShown = true;
            }
          }
        }

        if (animal.ttl !== null) {
          animal.ttl -= 1;
          if (animal.ttl <= 0) {
            animal.expiring = true;
          }
        }
      }
      state.animals = state.animals.filter((animal) => !(animal.expiring && animal.alpha <= 0.02));
      updateEcoDecorations();
    }

    function updateEcoDecorations() {
      const eco = state.ecoScore;
      const targetFerns = eco < 25 ? 0 : Math.min(18, Math.floor((eco - 20) / 4));
      const targetBushes = eco < 35 ? 0 : Math.min(12, Math.floor((eco - 30) / 6));
      const targetMeadow = eco < 45 ? 0 : Math.min(10, Math.floor((eco - 40) / 6));

      while (state.ferns.length < targetFerns) {
        let candidate = null;
        for (let attempt = 0; attempt < 10; attempt++) {
          const pt = { x: rand(60, WORLD.w - 60), y: rand(80, WORLD.h - 60) };
          if (!isInWater(pt, 10)) {
            candidate = pt;
            break;
          }
        }
        if (!candidate) break;
        state.ferns.push({
          x: candidate.x,
          y: candidate.y,
          sway: rand(0, Math.PI * 2),
          size: rand(6, 10)
        });
      }

      while (state.bushes.length < targetBushes) {
        let candidate = null;
        for (let attempt = 0; attempt < 10; attempt++) {
          const pt = { x: rand(80, WORLD.w - 80), y: rand(100, WORLD.h - 70) };
          if (!isInWater(pt, 12)) {
            candidate = pt;
            break;
          }
        }
        if (!candidate) break;
        state.bushes.push({
          x: candidate.x,
          y: candidate.y,
          size: rand(10, 16),
          spawnAt: state.t
        });
      }

      while (state.meadowGrass.length < targetMeadow) {
        let candidate = null;
        for (let attempt = 0; attempt < 10; attempt++) {
          const pt = { x: rand(90, WORLD.w - 90), y: rand(120, WORLD.h - 80) };
          if (!isInWater(pt, 12)) {
            candidate = pt;
            break;
          }
        }
        if (!candidate) break;
        state.meadowGrass.push(makeMeadowStrip(candidate.x, candidate.y));
      }
    }

    function makeMeadowStrip(x, y) {
      const bladeCount = 18 + Math.floor(rand(0, 11));
      const width = rand(44, 80);
      const blades = [];
      for (let i = 0; i < bladeCount; i++) {
        const t = bladeCount <= 1 ? 0 : (i / (bladeCount - 1));
        const edgeDist = Math.abs(t - 0.5) * 2;
        const heightFactor = 1 - edgeDist * 0.48;
        blades.push({
          dx: (t - 0.5) * width + rand(-1.2, 1.2),
          height: rand(5.0, 8.4) * heightFactor,
          tilt: rand(-0.22, 0.22),
          phase: rand(0, Math.PI * 2)
        });
      }
      return {
        x,
        y,
        width,
        blades,
        spawnAt: state.t
      };
    }

    function updateBeePopulation() {
      const cycle = getCycleInfo();
      if (cycle.isNight) {
        return;
      }
      const flowerCount = state.flowers.length;
      const baseTarget = Math.floor(flowerCount / 6);
      const maxBees = 7;
      const target = clamp(baseTarget, 0, maxBees);
      const current = state.animals.filter((animal) => animal.type === "bee").length;
      if (current < target) {
        for (let i = 0; i < target - current; i++) {
          spawnAnimal("bee", { minX: 140, maxX: WORLD.w - 140, minY: 140, maxY: WORLD.h - 80, padding: 16 }, { spawnFade: true });
        }
      } else if (current > target) {
        let toRemove = current - target;
        state.animals = state.animals.filter((animal) => {
          if (toRemove > 0 && animal.type === "bee") {
            toRemove -= 1;
            animal.expiring = true;
            return true;
          }
          return true;
        });
      }
    }

    function spawnButterflies(count, ttlRange) {
      for (let i = 0; i < count; i++) {
        const ttl = ttlRange ? Math.floor(rand(ttlRange[0], ttlRange[1])) : null;
        spawnAnimal(
          "butterfly",
          { minX: 120, maxX: WORLD.w - 120, minY: 140, maxY: WORLD.h - 90, padding: 16 },
          { ttl, spawnFade: true }
        );
      }
    }

    function ensureButterflies() {
      const cycle = getCycleInfo();
      if (cycle.isNight) {
        return;
      }
      if (state.butterflyBurstPending && !state.butterflyBurstDone) {
        if (getDaylightLevel() >= 0.98) {
          spawnButterflies(18, [60 * 20, 60 * 45]);
          state.butterflyBurstDone = true;
          state.butterflyBurstPending = false;
          logEvent("Triggered event: butterfly celebration burst");
        }
      }
      const persistent = state.animals.filter((animal) => animal.type === "butterfly" && animal.ttl === null).length;
      const target = 3;
      if (persistent < target) {
        spawnButterflies(target - persistent, null);
      }
    }

    function nearestFlower(point, maxDist) {
      let best = null;
      let bestDist = maxDist;
      for (const flower of state.flowers) {
        const d = distance(point, flower);
        if (d < bestDist) {
          bestDist = d;
          best = flower;
        }
      }
      return best;
    }

    function findLandPoint(minX, maxX, minY, maxY, padding = 12, attempts = 12) {
      for (let i = 0; i < attempts; i++) {
        const pt = { x: rand(minX, maxX), y: rand(minY, maxY) };
        if (!isInWater(pt, padding)) return pt;
      }
      return null;
    }

    function spawnAnimal(type, bounds, extra = {}) {
      const pt = findLandPoint(bounds.minX, bounds.maxX, bounds.minY, bounds.maxY, bounds.padding ?? 16, bounds.attempts ?? 10);
      if (!pt) return null;
      const animal = createAnimal(type, pt.x, pt.y, extra);
      state.animals.push(animal);
      return animal;
    }

    function countAnimals(type) {
      return state.animals.filter((animal) => animal.type === type && !animal.expiring).length;
    }

    function spawnBirdVisitor(bounds) {
      const maxBirds = 10;
      if (countAnimals("bird") >= maxBirds) return null;
      const ttl = Math.floor(rand(60 * 90, 60 * 210));
      return spawnAnimal("bird", bounds, { ttl, spawnFade: true });
    }

    function distPointToSegment(p, a, b) {
      const abx = b.x - a.x;
      const aby = b.y - a.y;
      const apx = p.x - a.x;
      const apy = p.y - a.y;
      const abLenSq = abx * abx + aby * aby;
      const t = abLenSq ? clamp((apx * abx + apy * aby) / abLenSq, 0, 1) : 0;
      const cx = a.x + abx * t;
      const cy = a.y + aby * t;
      return Math.hypot(p.x - cx, p.y - cy);
    }

    function isInStream(point, padding = 0) {
      if (!state.stream || !state.stream.points || state.stream.points.length < 2) return false;
      const pts = state.stream.points;
      for (let i = 0; i < pts.length - 1; i++) {
        if (distPointToSegment(point, pts[i], pts[i + 1]) <= (state.stream.width * 0.5 + padding)) {
          return true;
        }
      }
      return false;
    }

    function isInWater(point, padding = 0) {
      for (const puddle of state.puddles) {
        if (distance(point, puddle) <= puddle.r + padding) return true;
      }
      if (isInStream(point, padding)) return true;
      return false;
    }

    function isTreeTrunkOverWater(treePoint) {
      const samples = [
        { x: treePoint.x, y: treePoint.y + 16 },
        { x: treePoint.x, y: treePoint.y + 26 },
        { x: treePoint.x, y: treePoint.y + 36 },
        { x: treePoint.x, y: treePoint.y + 42 }
      ];
      for (const sample of samples) {
        if (isInWater(sample, 10)) return true;
      }
      return false;
    }

    function findDryTreePoint() {
      for (let attempt = 0; attempt < 60; attempt++) {
        const pt = { x: rand(80, WORLD.w - 80), y: rand(80, WORLD.h - 80) };
        if (!isTreeTrunkOverWater(pt)) return pt;
      }
      return null;
    }

    function sanitizeSaplingSpotsAgainstWater() {
      if (!state.saplingSpots.length) return;
      for (const spot of state.saplingSpots) {
        if (!isTreeTrunkOverWater(spot)) continue;
        const dryPoint = findDryTreePoint();
        if (!dryPoint) continue;
        spot.x = dryPoint.x;
        spot.y = dryPoint.y;
      }
    }

    function updateFireflies() {
      const cycle = getCycleInfo();
      const shouldShow = cycle.isNight && state.ecoScore >= 55;
      const nightIntro = shouldShow ? clamp((cycle.phase * CYCLE.nightFrames) / (60 * 60), 0, 1) : 0;
      const baseCount = Math.min(38, Math.floor((state.ecoScore - 45) * 0.7));
      const targetCount = Math.floor(baseCount * nightIntro);
      while (state.fireflies.length < targetCount) {
        state.fireflies.push(createFirefly());
      }
      for (let i = 0; i < state.fireflies.length; i++) {
        state.fireflies[i].visibleTarget = i < targetCount;
      }

      for (const firefly of state.fireflies) {
        if (firefly.fadeDelay > 0) {
          firefly.fadeDelay -= 1;
        } else {
          const targetAlpha = firefly.visibleTarget ? 1 : 0;
          const step = 1 / (60 * 2);
          if ((firefly.alpha ?? 0) < targetAlpha) {
            firefly.alpha = clamp((firefly.alpha ?? 0) + step, 0, 1);
          } else if ((firefly.alpha ?? 0) > targetAlpha) {
            firefly.alpha = clamp((firefly.alpha ?? 0) - step, 0, 1);
          }
        }
        if ((firefly.alpha ?? 0) <= 0.01 && !firefly.visibleTarget) {
          continue;
        }
        firefly.x += firefly.vx;
        firefly.y += firefly.vy;
        firefly.phase += firefly.pulse;

        if (firefly.x < 10 || firefly.x > WORLD.w - 10) firefly.vx *= -1;
        if (firefly.y < 50 || firefly.y > WORLD.h - 10) firefly.vy *= -1;

        if (Math.random() < 0.05) {
          firefly.vx = clamp(firefly.vx + rand(-0.1, 0.1), -0.5, 0.5);
          firefly.vy = clamp(firefly.vy + rand(-0.1, 0.1), -0.35, 0.35);
        }
      }
      state.fireflies = state.fireflies.filter((firefly) => firefly.visibleTarget || (firefly.alpha ?? 0) > 0.01);
    }

    function applySurprise(event) {
      state.stats.surprisesTriggered += 1;
      logEvent("Triggered surprise: " + event.kind);

      if (event.kind === "soil-recovery") {
        state.ecoScore = clamp(state.ecoScore + 1.5, 5, 100);
        logImpact("Soil recovery boosted eco health.");
        setMessage("Because of your cleanup, the soil recovered and little plants popped up.");
        return;
      }

      if (event.kind === "pollinator-arrival") {
        const bird = spawnBirdVisitor({
          minX: clamp(event.payload.x + rand(-40, 40) - 30, 40, WORLD.w - 40),
          maxX: clamp(event.payload.x + rand(-40, 40) + 30, 40, WORLD.w - 40),
          minY: clamp(event.payload.y + rand(-50, 30) - 30, 50, WORLD.h - 40),
          maxY: clamp(event.payload.y + rand(-50, 30) + 30, 50, WORLD.h - 40),
          padding: 18
        });
        if (bird) {
          state.stats.wildlifeFromSurprises += 1;
          logImpact("Pollinators visited around a " + event.payload.treeType + ".");
          setMessage("Because of your tree, pollinators found this area!");
        }
        return;
      }

      if (event.kind === "grass-tuft") {
        const count = 4 + Math.floor(rand(0, 3));
        for (let i = 0; i < count; i++) {
          let newPt = null;
          for (let attempt = 0; attempt < 8; attempt++) {
            const cand = {
              x: clamp(event.payload.x + rand(-22, 22), 20, WORLD.w - 20),
              y: clamp(event.payload.y + rand(8, 26), 20, WORLD.h - 20)
            };
            if (!isInWater(cand, 10)) {
              newPt = cand;
              break;
            }
          }
          if (!newPt) continue;
          state.grassTufts.push({
            x: newPt.x,
            y: newPt.y,
            sway: rand(0, Math.PI * 2),
            size: rand(3, 6),
            spawnAt: state.t
          });
        }
        logImpact("Tiny grass tufts appeared.");
        setMessage("New grass tufts sprouted around the young tree.");
        return;
      }

      if (event.kind === "fish-return") {
        logImpact("Fish returned near cleaner water.");
        setMessage("Because nearby areas got cleaner, fish returned to the pond.");
        scheduleSurprise("bird-visit", Math.floor(rand(60 * 30, 60 * 70)), {
          x: event.payload.x,
          y: event.payload.y
        });
        return;
      }

      if (event.kind === "bird-visit") {
        const bird = spawnBirdVisitor({
          minX: clamp(event.payload.x + rand(-60, 60) - 30, 40, WORLD.w - 40),
          maxX: clamp(event.payload.x + rand(-60, 60) + 30, 40, WORLD.w - 40),
          minY: clamp(event.payload.y + rand(-40, 20) - 30, 50, WORLD.h - 40),
          maxY: clamp(event.payload.y + rand(-40, 20) + 30, 50, WORLD.h - 40),
          padding: 18
        });
        if (bird) {
          state.stats.wildlifeFromSurprises += 1;
          logImpact("Birds came to the pond.");
          setMessage("Because fish returned, birds started visiting the pond.");
        }
      }
    }

    function updateSurprises() {
      if (state.surprises.length === 0) return;

      const ready = [];
      const pending = [];
      for (const s of state.surprises) {
        if (s.at <= state.t) ready.push(s);
        else pending.push(s);
      }
      state.surprises = pending;

      for (const s of ready) {
        applySurprise(s);
      }
    }

    function formatSurpriseQueue(limit) {
      if (state.surprises.length === 0) return "None";
      const sorted = state.surprises
        .slice()
        .sort((a, b) => a.at - b.at)
        .slice(0, limit)
        .map((s) => {
          const sec = Math.max(0, Math.round((s.at - state.t) / 60));
          return s.kind + " in ~" + sec + "s";
        });
      return sorted.join("\n");
    }

    function updateDebugPanel() {
      if (!state.debugPanelOpen) return;
      state.debugTick += 1;
      if (state.debugTick % 8 !== 0) return;

      const cycle = getCycleInfo();
      const matureTrees = state.saplingSpots.filter((s) => s.planted && s.growth > 0.65).length;
      const matureFlowers = state.flowers.filter((f) => f.growth > 0.7).length;
      const inactiveLitter = state.litterSpots.filter((s) => s.cleaned).length;
      const activeLitter = state.litterSpots.length - inactiveLitter;
      const dayState = cycle.isNight ? "Night" : "Day";

      ui.debugSystems.textContent =
        "Core loop:\\n" +
        "- Clean litter -> flowers + delayed spread + soil recovery\\n" +
        "- Plant trees -> growth -> mature tree acorn drops\\n" +
        "- Some young trees get thirsty -> collect water -> water them\\n" +
        "- Actions queue delayed surprise chains\\n" +
        "- Eco score drives wildlife and night fireflies\\n\\n" +
        "Surprise chains:\\n" +
        "- cleanup -> soil-recovery\\n" +
        "- cleanup near pond -> fish-return -> bird-visit\\n" +
        "- planting -> pollinator-arrival + grass-tuft";

      ui.debugPlaythrough.textContent =
        "Time: " + Math.floor(state.t / 60) + "s (" + dayState + ")\\n" +
        "Acorns: " + state.acorns + "\\n" +
        "Water: " + (state.waterCarried ? "Full" : "Empty") + "\\n" +
        "Planted: " + state.planted + "/" + GOAL.trees + "\\n" +
        "Cleaned: " + state.cleaned + "/" + GOAL.cleaned + "\\n" +
        "Eco: " + Math.round(state.ecoScore) + "% / " + GOAL.eco + "%\\n" +
        "Animals visible: " + getVisibleAnimals().length + "\\n" +
        "Flowers total: " + state.flowers.length + "\\n" +
        "Mature trees: " + matureTrees + "\\n" +
        "Mature flowers: " + matureFlowers + "\\n" +
        "Thirsty trees: " + countWiltedPlants();

      ui.debugQueue.textContent =
        "Queued: " + state.surprises.length + "\\n" +
        formatSurpriseQueue(10) + "\\n\\n" +
        "Recent impacts:\\n" +
        (state.recentImpacts.length ? state.recentImpacts.join("\\n") : "None yet");

      ui.debugInfluence.textContent =
        "Eco formula snapshot:\\n" +
        "5 + cleaned*5 + planted*4 + matureTrees*2 + matureFlowers*0.4\\n\\n" +
        "Current terms:\\n" +
        "cleaned(" + state.cleaned + ") => " + (state.cleaned * 5).toFixed(1) + "\\n" +
        "planted(" + state.planted + ") => " + (state.planted * 4).toFixed(1) + "\\n" +
        "matureTrees(" + matureTrees + ") => " + (matureTrees * 2).toFixed(1) + "\\n" +
        "matureFlowers(" + matureFlowers + ") => " + (matureFlowers * 0.4).toFixed(1) + "\\n" +
        "base => 5.0\\n\\n" +
        "Counters:\\n" +
        "surprisesTriggered: " + state.stats.surprisesTriggered + "\\n" +
        "flowerSpreadEvents: " + state.stats.flowerSpreadEvents + "\\n" +
        "treeAcornDrops: " + state.stats.treeAcornDrops + "\\n" +
        "wildlifeFromSurprises: " + state.stats.wildlifeFromSurprises + "\\n" +
        "litter active/clean: " + activeLitter + "/" + inactiveLitter;

      ui.debugEvents.textContent = state.eventLog.length
        ? state.eventLog.join("\\n")
        : "No triggered events yet.";
    }

    function openDebugPanel() {
      state.debugPanelOpen = true;
      ui.debugOverlay.classList.add("open");
      ui.debugOverlay.setAttribute("aria-hidden", "false");
      ui.debugEco.value = Math.round(state.ecoScore);
      ui.debugEcoValue.textContent = Math.round(state.ecoScore) + "%";
      updateDebugPanel();
      drawSpriteSamples();
    }

    function closeDebugPanel() {
      state.debugPanelOpen = false;
      ui.debugOverlay.classList.remove("open");
      ui.debugOverlay.setAttribute("aria-hidden", "true");
      if (state.ecoScore >= 100) {
        checkWin();
      }
    }

    function forceDay() {
      const cyclePos = 0;
      state.t = Math.floor(state.t / CYCLE.total) * CYCLE.total + cyclePos;
      update();
    }

    function forceNight() {
      const cyclePos = CYCLE.dayFrames + 1;
      state.t = Math.floor(state.t / CYCLE.total) * CYCLE.total + cyclePos;
      update();
    }

    function drawSpriteSamples() {
      const canvasSample = ui.spriteSample;
      if (!canvasSample) return;
      const sctx = canvasSample.getContext("2d");
      sctx.clearRect(0, 0, canvasSample.width, canvasSample.height);
      sctx.fillStyle = "#f3fbf2";
      sctx.fillRect(0, 0, canvasSample.width, canvasSample.height);

      const drawMound = (x, y) => {
        sctx.fillStyle = "#b58a5b";
        sctx.beginPath();
        sctx.moveTo(x - 16, y + 8);
        sctx.quadraticCurveTo(x, y - 6, x + 16, y + 8);
        sctx.closePath();
        sctx.fill();
        sctx.fillStyle = "#9e744c";
        sctx.beginPath();
        sctx.moveTo(x - 12, y + 8);
        sctx.quadraticCurveTo(x - 1, y - 4, x + 12, y + 8);
        sctx.closePath();
        sctx.fill();
      };

      const drawTree = (x, y, type) => {
        const crown = 20;
        const trunk = 20;
        const canopyMain = "rgb(" + PAPER.canopyA.join(",") + ")";
        const canopyAlt = "rgb(" + PAPER.canopyB.join(",") + ")";
        if (type === "Pine") {
          sctx.fillStyle = canopyAlt;
          sctx.beginPath();
          sctx.moveTo(x, y - crown);
          sctx.lineTo(x - crown * 0.55, y + crown * 0.1);
          sctx.lineTo(x + crown * 0.55, y + crown * 0.1);
          sctx.closePath();
          sctx.fill();
          sctx.fillStyle = canopyMain;
          sctx.beginPath();
          sctx.moveTo(x, y - crown * 0.7);
          sctx.lineTo(x - crown * 0.42, y + crown * 0.22);
          sctx.lineTo(x + crown * 0.42, y + crown * 0.22);
          sctx.closePath();
          sctx.fill();
        } else if (type === "Aspen") {
          sctx.fillStyle = canopyAlt;
          sctx.beginPath();
          sctx.ellipse(x, y - crown * 0.5, crown * 0.7, crown * 0.5, 0, 0, Math.PI * 2);
          sctx.fill();
          sctx.fillStyle = canopyMain;
          sctx.beginPath();
          sctx.ellipse(x, y - crown * 0.6, crown * 0.55, crown * 0.42, 0, 0, Math.PI * 2);
          sctx.fill();
          sctx.fillStyle = "rgba(255, 255, 255, 0.25)";
          for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 * i) / 12;
            const lx = x + Math.cos(angle) * crown * 0.4;
            const ly = y - crown * 0.55 + Math.sin(angle) * crown * 0.2;
            sctx.beginPath();
            sctx.ellipse(lx, ly, 2, 1.4, angle, 0, Math.PI * 2);
            sctx.fill();
          }
        } else {
          sctx.fillStyle = canopyAlt;
          sctx.beginPath();
          sctx.ellipse(x - crown * 0.35, y - crown * 0.2, crown * 0.55, crown * 0.45, 0, 0, Math.PI * 2);
          sctx.fill();
          sctx.fillStyle = canopyMain;
          sctx.beginPath();
          sctx.ellipse(x + crown * 0.2, y - crown * 0.3, crown * 0.65, crown * 0.55, 0, 0, Math.PI * 2);
          sctx.fill();
        }
        sctx.fillStyle = "rgb(" + PAPER.trunk.join(",") + ")";
        sctx.fillRect(x - 4, y + 6, 8, trunk);
      };

      const drawLitter = (x, y) => {
        sctx.strokeStyle = "rgba(80, 70, 55, 0.65)";
        sctx.lineWidth = 1;
        const colors = ["#ff7aa2", "#56c2ff", "#f7d36f"];
        for (let i = 0; i < 3; i++) {
          sctx.fillStyle = colors[i];
          sctx.save();
          sctx.translate(x + i * 5, y - i * 2);
          sctx.rotate((i - 1) * 0.2);
          sctx.beginPath();
          sctx.rect(-6, -4, 12, 8);
          sctx.fill();
          sctx.stroke();
          sctx.restore();
        }
      };

      const drawAcorn = (x, y) => {
        sctx.fillStyle = "#b07a45";
        sctx.beginPath();
        sctx.ellipse(x, y, 7, 9, 0, 0, Math.PI * 2);
        sctx.fill();
        sctx.strokeStyle = "#7a5632";
        sctx.stroke();
        sctx.fillStyle = "#8a5a2c";
        sctx.fillRect(x - 7, y - 7, 14, 3);
      };

      const drawAnimal = (x, y) => {
        sctx.fillStyle = "#d9c7b3";
        sctx.beginPath();
        sctx.ellipse(x, y, 11, 8, 0, 0, Math.PI * 2);
        sctx.fill();
        sctx.strokeStyle = "rgba(60, 50, 40, 0.4)";
        sctx.stroke();
      };

      const drawFlower = (x, y) => {
        sctx.strokeStyle = "rgb(" + PAPER.flowerStem.join(",") + ")";
        sctx.beginPath();
        sctx.moveTo(x, y + 8);
        sctx.lineTo(x + 2, y - 6);
        sctx.stroke();
        sctx.fillStyle = "#ffd166";
        sctx.beginPath();
        sctx.arc(x + 2, y - 6, 3, 0, Math.PI * 2);
        sctx.fill();
      };

      drawMound(60, 190);
      drawTree(90, 150, "Maple");
      drawTree(160, 150, "Pine");
      drawTree(230, 150, "Aspen");
      drawLitter(300, 185);
      drawAcorn(350, 175);
      drawCampsiteItem({ id: "tent", x: 410, y: 175 }, sctx);
      drawAnimal(470, 175);
      drawFlower(530, 180);
    }
    function checkWin() {
      const restored = state.planted >= GOAL.trees &&
                       state.cleaned >= GOAL.cleaned &&
                       state.ecoScore >= GOAL.eco;

      if (restored && !state.won) {
        state.won = true;
        if (!state.butterflyBurstDone) {
          const cycle = getCycleInfo();
          if (cycle.isNight) {
            state.butterflyBurstPending = true;
          } else {
            spawnButterflies(18, [60 * 20, 60 * 45]);
            state.butterflyBurstDone = true;
          }
        }

        const score = Math.floor(state.cleaned * 15 + state.planted * 12 + state.flowers.length * 2 + state.ecoScore * 2);
        if (score > state.bestScore) {
          state.bestScore = score;
          localStorage.setItem("forest-best", String(score));
        }

        setMessage("Forest thriving! Score: " + score + ". Keep exploring.");
      }
    }

    function getEcoBlend() {
      return clamp(state.ecoScore / 100, 0, 1);
    }

    function drawGround() {
      const daylight = getDaylightLevel();
      const nightAmount = 1 - daylight;
      const ecoBlend = getEcoBlend();
      const dayBase = [
        Math.round(PAPER.groundDay[0] + ecoBlend * 16),
        Math.round(PAPER.groundDay[1] + ecoBlend * 14),
        Math.round(PAPER.groundDay[2] + ecoBlend * 10)
      ];
      const nightBase = [
        Math.round(PAPER.groundNight[0] + ecoBlend * 6),
        Math.round(PAPER.groundNight[1] + ecoBlend * 8),
        Math.round(PAPER.groundNight[2] + ecoBlend * 5)
      ];

      ctx.fillStyle = mixColor(dayBase, nightBase, nightAmount);
      ctx.fillRect(0, 0, WORLD.w, WORLD.h);
      const pattern = ensureGrassPattern();
      if (pattern) {
        ctx.save();
        ctx.globalAlpha = (0.22 + ecoBlend * 0.12) - nightAmount * 0.1;
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, WORLD.w, WORLD.h);
        ctx.restore();
      }

      for (const puddle of state.puddles) {
        const bankDay = [
          Math.round(PAPER.grassDay[0] + ecoBlend * 10),
          Math.round(PAPER.grassDay[1] + ecoBlend * 8),
          Math.round(PAPER.grassDay[2] + ecoBlend * 6)
        ];
        const bankNight = [
          Math.round(PAPER.grassNight[0] + ecoBlend * 6),
          Math.round(PAPER.grassNight[1] + ecoBlend * 6),
          Math.round(PAPER.grassNight[2] + ecoBlend * 5)
        ];
        const bankColor = mixColor(bankDay, bankNight, nightAmount);
        ctx.fillStyle = bankColor;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.ellipse(puddle.x, puddle.y + 2, puddle.r + 8, puddle.r * 0.74, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        const waterDay = [
          Math.round(PAPER.waterDay[0] + ecoBlend * 6),
          Math.round(PAPER.waterDay[1] + ecoBlend * 6),
          Math.round(PAPER.waterDay[2] + ecoBlend * 4)
        ];
        const waterNight = [
          Math.round(PAPER.waterNight[0] + ecoBlend * 5),
          Math.round(PAPER.waterNight[1] + ecoBlend * 5),
          Math.round(PAPER.waterNight[2] + ecoBlend * 4)
        ];
        ctx.fillStyle = mixColor(waterDay, waterNight, nightAmount);
        ctx.beginPath();
        ctx.ellipse(puddle.x, puddle.y, puddle.r, puddle.r * 0.6, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(250, 252, 255, " + (0.35 - nightAmount * 0.16).toFixed(3) + ")";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(puddle.x, puddle.y, puddle.r * 0.75, puddle.r * 0.42, 0.2, 0, Math.PI * 2);
        ctx.stroke();
      }

      if (nightAmount > 0) {
        ctx.fillStyle = "rgba(14, 30, 24, " + (nightAmount * 0.36).toFixed(3) + ")";
        ctx.fillRect(0, 0, WORLD.w, WORLD.h);
      }
    }

    function drawStream() {
      if (!state.stream) return;
      const nightAmount = 1 - getDaylightLevel();
      const ecoBlend = getEcoBlend();
      const waterDay = [
        Math.round(PAPER.waterDay[0] + 24 + ecoBlend * 6),
        Math.round(PAPER.waterDay[1] + 18 + ecoBlend * 6),
        Math.round(PAPER.waterDay[2] + 10 + ecoBlend * 4)
      ];
      const waterNight = [
        Math.round(PAPER.waterNight[0] + 16 + ecoBlend * 5),
        Math.round(PAPER.waterNight[1] + 12 + ecoBlend * 5),
        Math.round(PAPER.waterNight[2] + 8 + ecoBlend * 4)
      ];
      const bankDay = [
        Math.round(PAPER.grassDay[0] - 10),
        Math.round(PAPER.grassDay[1] - 10),
        Math.round(PAPER.grassDay[2] - 8)
      ];
      const bankNight = [
        Math.round(PAPER.grassNight[0] - 6),
        Math.round(PAPER.grassNight[1] - 6),
        Math.round(PAPER.grassNight[2] - 5)
      ];
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      const drawStreamPath = () => {
        const pts = state.stream.points || [];
        if (pts.length < 2) return;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length - 1; i++) {
          const curr = pts[i];
          const next = pts[i + 1];
          const midX = (curr.x + next.x) / 2;
          const midY = (curr.y + next.y) / 2;
          ctx.quadraticCurveTo(curr.x, curr.y, midX, midY);
        }
        const last = pts[pts.length - 1];
        ctx.lineTo(last.x, last.y);
      };

      const sampleQuadraticPoint = (a, c, b, t) => {
        const mt = 1 - t;
        return {
          x: mt * mt * a.x + 2 * mt * t * c.x + t * t * b.x,
          y: mt * mt * a.y + 2 * mt * t * c.y + t * t * b.y
        };
      };

      const buildStreamCurvePoints = (pts, quadSteps = 14, lineSteps = 10) => {
        if (!pts || pts.length < 2) return [];
        const out = [{ x: pts[0].x, y: pts[0].y }];
        let start = { x: pts[0].x, y: pts[0].y };
        for (let i = 1; i < pts.length - 1; i++) {
          const ctrl = pts[i];
          const next = pts[i + 1];
          const end = { x: (ctrl.x + next.x) / 2, y: (ctrl.y + next.y) / 2 };
          for (let s = 1; s <= quadSteps; s++) {
            const t = s / quadSteps;
            out.push(sampleQuadraticPoint(start, ctrl, end, t));
          }
          start = end;
        }
        const last = pts[pts.length - 1];
        for (let s = 1; s <= lineSteps; s++) {
          const t = s / lineSteps;
          out.push({
            x: start.x + (last.x - start.x) * t,
            y: start.y + (last.y - start.y) * t
          });
        }
        return out;
      };

      const getStreamPolylineData = () => {
        const pts = buildStreamCurvePoints(state.stream.points || []);
        const segments = [];
        let total = 0;
        for (let i = 0; i < pts.length - 1; i++) {
          const a = pts[i];
          const b = pts[i + 1];
          const len = Math.hypot(b.x - a.x, b.y - a.y);
          if (len <= 0.001) continue;
          segments.push({ a, b, len, start: total, end: total + len });
          total += len;
        }
        return { segments, total };
      };

      const sampleStreamAt = (polyline, dist) => {
        if (!polyline || polyline.total <= 0 || polyline.segments.length === 0) return null;
        let d = dist % polyline.total;
        if (d < 0) d += polyline.total;
        for (const seg of polyline.segments) {
          if (d <= seg.end) {
            const local = (d - seg.start) / seg.len;
            const x = seg.a.x + (seg.b.x - seg.a.x) * local;
            const y = seg.a.y + (seg.b.y - seg.a.y) * local;
            const tx = (seg.b.x - seg.a.x) / seg.len;
            const ty = (seg.b.y - seg.a.y) / seg.len;
            return { x, y, tx, ty };
          }
        }
        const last = polyline.segments[polyline.segments.length - 1];
        const tx = (last.b.x - last.a.x) / last.len;
        const ty = (last.b.y - last.a.y) / last.len;
        return { x: last.b.x, y: last.b.y, tx, ty };
      };

      ctx.strokeStyle = mixColor(waterDay, waterNight, nightAmount);
      ctx.lineWidth = state.stream.width * 0.8;
      drawStreamPath();
      ctx.stroke();

      ctx.strokeStyle = "rgba(250, 252, 255, " + (0.38 - nightAmount * 0.16).toFixed(3) + ")";
      ctx.lineWidth = Math.max(4, state.stream.width * 0.38);
      drawStreamPath();
      ctx.stroke();

      // Subtle per-marker flow with independent wiggle.
      ctx.save();
      ctx.strokeStyle = "rgba(255, 255, 255, " + (0.24 - nightAmount * 0.12).toFixed(3) + ")";
      ctx.lineWidth = Math.max(1.2, state.stream.width * 0.1);
      const polyline = getStreamPolylineData();
      const flowMarks = state.stream.flowMarks || [];
      const flowSpeed = 0.35;
      for (const mark of flowMarks) {
        const baseDist = mark.base * polyline.total;
        const dist = baseDist + state.t * flowSpeed;
        const head = sampleStreamAt(polyline, dist);
        if (!head) continue;
        const prev = sampleStreamAt(polyline, dist - 10);
        const next = sampleStreamAt(polyline, dist + 10);
        let bendScale = 1;
        if (prev && next) {
          const dot = clamp(prev.tx * next.tx + prev.ty * next.ty, -1, 1);
          const angle = Math.acos(dot);
          bendScale = clamp(1 - angle * 1.3, 0.25, 1);
        }
        const nx = -head.ty;
        const ny = head.tx;
        const maxWiggle = state.stream.width * 0.12;
        const wiggleRaw = Math.sin(state.t * 0.045 + mark.phase) * mark.amp;
        const wiggle = clamp(wiggleRaw * bendScale, -maxWiggle, maxWiggle);
        const x1 = head.x + nx * wiggle;
        const y1 = head.y + ny * wiggle;
        const x2 = x1 + head.tx * mark.length;
        const y2 = y1 + head.ty * mark.length;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.restore();

      if (state.debugStreamOutline) {
        ctx.strokeStyle = "rgba(255, 80, 80, 0.8)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        drawStreamPath();
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    function drawMobileMiniMap() {
      if (!isMobileViewport()) return;

      const zoom = state.camera.zoom || 1;
      const camX = state.camera.x || 0;
      const camY = state.camera.y || 0;
      const viewW = canvas.width / zoom;
      const viewH = canvas.height / zoom;

      const mapW = Math.max(96, Math.min(128, Math.round(canvas.width * 0.22)));
      const mapH = Math.round(mapW * (WORLD.h / WORLD.w));
      const padX = 12;
      const padY = 12;

      const frameX = padX;
      const frameY = padY;
      const innerX = frameX + 4;
      const innerY = frameY + 4;
      const innerW = mapW - 8;
      const innerH = mapH - 8;

      const viewX = innerX + (camX / WORLD.w) * innerW;
      const viewY = innerY + (camY / WORLD.h) * innerH;
      const viewBoxW = Math.max(8, (viewW / WORLD.w) * innerW);
      const viewBoxH = Math.max(8, (viewH / WORLD.h) * innerH);

      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "rgba(248, 255, 244, 0.64)";
      ctx.strokeStyle = "rgba(27, 71, 41, 0.65)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.rect(frameX, frameY, mapW, mapH);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "rgba(115, 170, 98, 0.32)";
      ctx.fillRect(innerX, innerY, innerW, innerH);

      ctx.strokeStyle = "rgba(255, 255, 255, 0.75)";
      ctx.lineWidth = 1;
      ctx.strokeRect(
        clamp(viewX, innerX, innerX + innerW - viewBoxW),
        clamp(viewY, innerY, innerY + innerH - viewBoxH),
        viewBoxW,
        viewBoxH
      );
      ctx.restore();
    }

    function drawLeaves() {
      ctx.fillStyle = "rgba(237, 174, 83, 0.8)";
      for (const leaf of state.leaves) {
        ctx.beginPath();
        ctx.ellipse(leaf.x, leaf.y, 3.5, 2.1, 0.6, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawAcorns() {
      for (const acorn of state.acornNodes) {
        if (!acorn.active) continue;
        const bob = 0;
        drawShadowEllipse(acorn.x + 2, acorn.y + 10 + bob, 6, 3, 0.18);
        ctx.fillStyle = "#b07a45";
        ctx.beginPath();
        ctx.ellipse(acorn.x, acorn.y + bob, 7, 9, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#7a5632";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.fillStyle = "#8a5a2c";
        ctx.fillRect(acorn.x - 7, acorn.y - 7 + bob, 14, 3);
      }
    }

    function drawSpots(saplingSpots = state.saplingSpots, litterSpots = state.litterSpots) {
      for (const spot of saplingSpots) {
        if (!spot.planted) {
          ctx.fillStyle = "#b58a5b";
          ctx.beginPath();
          ctx.moveTo(spot.x - 13, spot.y + 7);
          ctx.quadraticCurveTo(spot.x, spot.y - 4, spot.x + 13, spot.y + 7);
          ctx.lineTo(spot.x - 13, spot.y + 7);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = "#9e744c";
          ctx.beginPath();
          ctx.moveTo(spot.x - 10, spot.y + 7);
          ctx.quadraticCurveTo(spot.x - 1, spot.y - 3, spot.x + 10, spot.y + 7);
          ctx.lineTo(spot.x - 10, spot.y + 7);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "rgba(90, 70, 45, 0.6)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(spot.x - 13, spot.y + 7);
          ctx.quadraticCurveTo(spot.x, spot.y - 4, spot.x + 13, spot.y + 7);
          ctx.stroke();
        } else {
          const nightAmount = 1 - getDaylightLevel();
          const growth = spot.growth || 0.04;
          const wiltBlend = clamp(spot.wiltBlend ?? (spot.wilted ? 1 : 0), 0, 1);
          const crown = (10 + growth * 18) * 2;
          const trunk = (6 + growth * 12) * 2;
          const swayStrength = (0.9 + growth) * (1 - 0.35 * wiltBlend);
          const sway = Math.sin(state.t * 0.018 + spot.x * 0.018 + spot.y * 0.009) * swayStrength;
          const trunkDay = blendRgb(PAPER.trunk, [125, 92, 61], wiltBlend);
          const trunkNight = blendRgb(PAPER.trunkNight, [80, 60, 45], wiltBlend);
          const trunkColor = mixColor(trunkDay, trunkNight, nightAmount);
          const trunkEdge = "rgba(70, 50, 30, 0.6)";

          const trunkTopY = spot.y + crown * 0.08;
          ctx.fillStyle = trunkColor;
          ctx.fillRect(spot.x - 4 + sway * 0.25, trunkTopY, 8, trunk);
          ctx.strokeStyle = trunkEdge;
          ctx.strokeRect(spot.x - 4 + sway * 0.25, trunkTopY, 8, trunk);
        }
      }

      for (const spot of litterSpots) {
        if (!spot.cleaned) {
          drawShadowEllipse(spot.x + 3, spot.y + 10, 10, 4, 0.18);
          const seed = Math.sin(spot.x * 0.13 + spot.y * 0.17) * 43758.5453;
          const frac = seed - Math.floor(seed);
          const clumpCount = spot.variant || (frac > 0.55 ? 3 : 2);
          const colors = ["#ff7aa2", "#56c2ff", "#f7d36f"];
          ctx.strokeStyle = "rgba(80, 70, 55, 0.65)";
          ctx.lineWidth = 1;
          for (let i = 0; i < clumpCount; i++) {
            const offsetSeed = Math.sin(spot.x * 0.21 + spot.y * 0.19 + i * 2.1) * 24634.6345;
            const offsetFrac = offsetSeed - Math.floor(offsetSeed);
            const dx = (offsetFrac * 2 - 1) * 6;
            const dy = Math.sin(offsetSeed) * 4;
            const w = 8 + (offsetFrac * 4);
            const h = 6 + (1 - offsetFrac) * 3;
            ctx.fillStyle = colors[(Math.floor(offsetFrac * colors.length) + i) % colors.length];
            const angle = (offsetFrac - 0.5) * 0.7;
            ctx.save();
            ctx.translate(spot.x + dx, spot.y + dy);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.rect(-w / 2, -h / 2, w, h);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }
        } else {
          // cleaned spot marker removed for a cleaner look
        }
      }
    }

    function drawTreeCanopies(saplingSpots = state.saplingSpots) {
      for (const spot of saplingSpots) {
        if (!spot.planted) continue;
        const nightAmount = 1 - getDaylightLevel();
        const growth = spot.growth || 0.04;
        const wiltBlend = clamp(spot.wiltBlend ?? (spot.wilted ? 1 : 0), 0, 1);
        const crown = (10 + growth * 18) * 2;
        const swayStrength = (0.9 + growth) * (1 - 0.35 * wiltBlend);
        const sway = Math.sin(state.t * 0.018 + spot.x * 0.018 + spot.y * 0.009) * swayStrength;
        const topX = spot.x + sway;
        const canopyMainDay = blendRgb(PAPER.canopyA, [179, 123, 71], wiltBlend);
        const canopyMainNight = blendRgb(PAPER.canopyNight, [90, 70, 50], wiltBlend);
        const canopyAltDay = blendRgb(PAPER.canopyB, [155, 106, 60], wiltBlend);
        const canopyAltNight = blendRgb(PAPER.canopyNight, [80, 62, 45], wiltBlend);
        const canopyMain = mixColor(canopyMainDay, canopyMainNight, nightAmount);
        const canopyAlt = mixColor(canopyAltDay, canopyAltNight, nightAmount);

        if (spot.treeType === "Pine" || spot.treeType === "Cedar") {
          ctx.fillStyle = canopyAlt;
          ctx.beginPath();
          ctx.moveTo(topX, spot.y - crown);
          ctx.lineTo(topX - crown * 0.55, spot.y + crown * 0.1);
          ctx.lineTo(topX + crown * 0.55, spot.y + crown * 0.1);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = canopyMain;
          ctx.beginPath();
          ctx.moveTo(topX, spot.y - crown * 0.7);
          ctx.lineTo(topX - crown * 0.42, spot.y + crown * 0.22);
          ctx.lineTo(topX + crown * 0.42, spot.y + crown * 0.22);
          ctx.closePath();
          ctx.fill();
        } else if (spot.treeType === "Aspen") {
          ctx.fillStyle = canopyAlt;
          ctx.beginPath();
          ctx.ellipse(topX, spot.y - crown * 0.5, crown * 0.7, crown * 0.5, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = canopyMain;
          ctx.beginPath();
          ctx.ellipse(topX, spot.y - crown * 0.6, crown * 0.55, crown * 0.42, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
          for (let i = 0; i < 16; i++) {
            const angle = (Math.PI * 2 * i) / 16;
            const rx = crown * (0.2 + 0.18 * Math.sin(i));
            const ry = crown * (0.18 + 0.12 * Math.cos(i));
            const lx = topX + Math.cos(angle) * rx;
            const ly = spot.y - crown * 0.55 + Math.sin(angle) * ry;
            ctx.beginPath();
            ctx.ellipse(lx, ly, 2.3, 1.6, angle, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (spot.treeType === "Birch") {
          ctx.fillStyle = canopyAlt;
          ctx.beginPath();
          ctx.ellipse(topX - crown * 0.25, spot.y - crown * 0.35, crown * 0.5, crown * 0.4, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = canopyMain;
          ctx.beginPath();
          ctx.ellipse(topX + crown * 0.2, spot.y - crown * 0.4, crown * 0.6, crown * 0.5, 0, 0, Math.PI * 2);
          ctx.fill();
        } else if (spot.treeType === "Maple") {
          ctx.fillStyle = canopyMain;
          ctx.beginPath();
          ctx.ellipse(topX, spot.y - crown * 0.45, crown * 0.75, crown * 0.6, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = canopyAlt;
          ctx.beginPath();
          ctx.ellipse(topX - crown * 0.25, spot.y - crown * 0.2, crown * 0.6, crown * 0.48, 0, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = canopyAlt;
          ctx.beginPath();
          ctx.ellipse(topX - crown * 0.35, spot.y - crown * 0.2, crown * 0.55, crown * 0.45, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = canopyMain;
          ctx.beginPath();
          ctx.ellipse(topX + crown * 0.2, spot.y - crown * 0.3, crown * 0.65, crown * 0.55, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.strokeStyle = "rgba(50, 70, 55, 0.5)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function drawFlowers() {
      for (const flower of state.flowers) {
        const size = 3 + flower.growth * 7;
        const stem = 4 + flower.growth * 6;
        const sway = Math.sin(state.t * 0.03 + flower.x * 0.05 + flower.y * 0.03) * (0.4 + flower.growth * 0.8);
        const bloomX = flower.x + sway;
        const bloomY = flower.y + 8 - stem;

        ctx.strokeStyle = "rgb(" + PAPER.flowerStem.join(",") + ")";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(flower.x, flower.y + 8);
        ctx.lineTo(bloomX, bloomY);
        ctx.stroke();

        ctx.fillStyle = flower.color;
        for (let i = 0; i < 5; i++) {
          const a = (Math.PI * 2 * i) / 5 + state.t * 0.002;
          ctx.beginPath();
          ctx.arc(
            bloomX + Math.cos(a) * (size * 0.6),
            bloomY + Math.sin(a) * (size * 0.6),
            size * 0.35,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }

        ctx.fillStyle = "#f6d77b";
        ctx.beginPath();
        ctx.arc(bloomX, bloomY, size * 0.28, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawGrassTufts() {
      for (const tuft of state.grassTufts) {
        const sway = Math.sin(state.t * 0.03 + tuft.sway) * 0.6;
        const intro = introGrow(tuft, 170);
        const size = (tuft.size || 4) * intro;
        if (size < 0.2) continue;
        ctx.save();
        ctx.globalAlpha = 0.2 + intro * 0.8;
        ctx.strokeStyle = "#6f9b6a";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(tuft.x - 3, tuft.y + 6);
        ctx.lineTo(tuft.x - 4 + sway, tuft.y + 6 - size);
        ctx.moveTo(tuft.x, tuft.y + 6);
        ctx.lineTo(tuft.x + sway, tuft.y + 6 - size * 1.2);
        ctx.moveTo(tuft.x + 3, tuft.y + 6);
        ctx.lineTo(tuft.x + 4 + sway, tuft.y + 6 - size * 0.9);
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawEcoDecorations() {
      ctx.strokeStyle = "#6e9a68";
      ctx.lineWidth = 1.05;
      for (const line of state.meadowGrass) {
        if (!Array.isArray(line.blades) || line.blades.length === 0) {
          const migrated = makeMeadowStrip(line.x, line.y);
          line.width = migrated.width;
          line.blades = migrated.blades;
        }
        const intro = introGrow(line, 190);
        if (intro <= 0.01) continue;
        ctx.save();
        ctx.globalAlpha = 0.2 + intro * 0.8;
        for (const blade of line.blades) {
          const sway = Math.sin(state.t * 0.018 + blade.phase) * 0.35;
          const baseX = line.x + blade.dx;
          const tipX = baseX + blade.tilt + sway;
          const tipY = line.y - blade.height * intro;
          ctx.beginPath();
          ctx.moveTo(baseX, line.y);
          ctx.lineTo(tipX, tipY);
          ctx.stroke();
        }
        ctx.restore();
      }

      for (const fern of state.ferns) {
        const sway = Math.sin(state.t * 0.025 + fern.sway) * 1.2;
        ctx.strokeStyle = "#6a9668";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(fern.x, fern.y + 6);
        ctx.lineTo(fern.x + sway, fern.y - fern.size);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(fern.x - 4, fern.y + 6);
        ctx.lineTo(fern.x - 6 + sway, fern.y - fern.size * 0.6);
        ctx.moveTo(fern.x + 4, fern.y + 6);
        ctx.lineTo(fern.x + 6 + sway, fern.y - fern.size * 0.6);
        ctx.stroke();
      }

      for (const bush of state.bushes) {
        const intro = introGrow(bush, 180);
        if (intro <= 0.01) continue;
        const grown = bush.size * intro;
        ctx.save();
        ctx.globalAlpha = 0.2 + intro * 0.8;
        ctx.fillStyle = "#6f9a71";
        ctx.beginPath();
        ctx.ellipse(bush.x, bush.y, grown, grown * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#5f8c61";
        ctx.beginPath();
        ctx.ellipse(bush.x - grown * 0.4, bush.y + 1, grown * 0.6, grown * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawCampsiteItem(item, targetCtx) {
      const ctxRef = targetCtx || ctx;
      if (!item) return;
      const bob = Math.sin(state.t * 0.02 + item.x * 0.01) * 0.4;
      if (item.id === "tent") {
        ctxRef.fillStyle = "#ead7b2";
        ctxRef.beginPath();
        ctxRef.moveTo(item.x, item.y - 16 + bob);
        ctxRef.lineTo(item.x - 18, item.y + 10 + bob);
        ctxRef.lineTo(item.x + 18, item.y + 10 + bob);
        ctxRef.closePath();
        ctxRef.fill();
        ctxRef.strokeStyle = "#9a7a4f";
        ctxRef.stroke();
      } else if (item.id === "firepit") {
        ctxRef.fillStyle = "#7a5534";
        ctxRef.beginPath();
        ctxRef.arc(item.x, item.y + 8 + bob, 12, 0, Math.PI * 2);
        ctxRef.fill();
        ctxRef.fillStyle = "#e38a3e";
        ctxRef.beginPath();
        ctxRef.arc(item.x, item.y + 4 + bob, 5, 0, Math.PI * 2);
        ctxRef.fill();
      } else if (item.id === "log-seats") {
        ctxRef.fillStyle = "#8f5f33";
        ctxRef.fillRect(item.x - 16, item.y + 4 + bob, 32, 8);
        ctxRef.fillStyle = "#6f4a28";
        ctxRef.fillRect(item.x - 14, item.y + 6 + bob, 28, 4);
      } else if (item.id === "lantern") {
        ctxRef.fillStyle = "#4d6a6a";
        ctxRef.fillRect(item.x - 3, item.y - 6 + bob, 6, 14);
        ctxRef.fillStyle = "rgba(255, 230, 140, 0.85)";
        ctxRef.beginPath();
        ctxRef.arc(item.x, item.y + 6 + bob, 6, 0, Math.PI * 2);
        ctxRef.fill();
      }
    }

    function drawCampsiteItems() {
      for (const item of state.campsiteItems) {
        drawCampsiteItem(item);
      }
    }

    function drawPlacementPreview() {
      if (!state.buildMode || !state.mouseWorld) return;
      const entry = CAMPSITE_LOOKUP[state.buildMode];
      if (!entry) return;
      const point = state.mouseWorld;
      const ok = canPlaceCampsiteItem(point);
      ctx.save();
      ctx.globalAlpha = 0.65;
      if (!ok) ctx.globalAlpha = 0.35;
      const preview = { id: entry.id, x: point.x, y: point.y };
      drawCampsiteItem(preview);
      ctx.restore();
    }

    function drawAnimals() {
      for (const animal of getVisibleAnimals()) {
        let bobY = Math.sin(animal.bob) * 1.4;
        if (animal.type === "owl") {
          bobY = Math.sin(animal.bob * 0.8) * 3.2 + Math.sin(state.t * 0.045 + animal.x * 0.01) * 1.6;
        }
        const x = animal.x;
        const y = animal.y + bobY;
        animal.bob += 0.04;

        ctx.save();
        ctx.globalAlpha = animal.alpha ?? 1;
        let shadowW = 9;
        let bodyW = 11;
        let bodyH = 8;
        if (animal.type === "bear") { shadowW = 12; bodyW = 14; bodyH = 10; }
        if (animal.type === "moose") { shadowW = 11; bodyW = 13; bodyH = 9; }
        if (animal.type === "deer") { shadowW = 14; bodyW = 18; bodyH = 8; }
        if (animal.type === "squirrel") { shadowW = 7; bodyW = 8; bodyH = 6; }
        if (animal.type === "owl") { shadowW = 8; bodyW = 7; bodyH = 12; }
        drawShadowEllipse(x + 3, y + 12, shadowW, 3, 0.16);

        const bodyByType = {
          rabbit: "#7f7367",
          bird: "#5f6f7d",
          deer: "#7b6043",
          fox: "#8b5d3a",
          owl: "#6b665c",
          squirrel: "#6f533a",
          raccoon: "#666a72",
          bear: "#5f4d3d",
          moose: "#6a4f3b",
          bee: "#4f4738",
          butterfly: "#685c73"
        };
        const body = bodyByType[animal.type] || "#66554a";

        if (animal.type === "bee") {
          ctx.fillStyle = "#f5bf33";
          ctx.beginPath();
          ctx.ellipse(x, y, 6, 4, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#2c2a25";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(x - 2.5, y - 1);
          ctx.lineTo(x + 2.5, y - 1);
          ctx.moveTo(x - 3, y + 1);
          ctx.lineTo(x + 3, y + 1);
          ctx.stroke();
          ctx.fillStyle = "rgba(240, 248, 255, 0.8)";
          ctx.beginPath();
          ctx.ellipse(x - 3, y - 4, 3, 1.6, -0.4, 0, Math.PI * 2);
          ctx.ellipse(x + 3, y - 4, 3, 1.6, 0.4, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          continue;
        }

        if (animal.type === "butterfly") {
          ctx.fillStyle = "#f5a7c3";
          ctx.beginPath();
          ctx.ellipse(x - 4, y, 4, 5, -0.2, 0, Math.PI * 2);
          ctx.ellipse(x + 4, y, 4, 5, 0.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(90, 60, 60, 0.5)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y - 4);
          ctx.lineTo(x, y + 5);
          ctx.stroke();
          ctx.restore();
          continue;
        }

        if (animal.type === "bird") {
          // Bird silhouette: horizontal body core + triangular wings (top and bottom).
          ctx.fillStyle = body;
          ctx.beginPath();
          ctx.ellipse(x, y, 8.2, 4.1, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(x - 3.1, y - 1.2);
          ctx.lineTo(x + 1.2, y - 10.2);
          ctx.lineTo(x + 5.1, y - 1.2);
          ctx.closePath();
          ctx.moveTo(x - 3.1, y + 1.2);
          ctx.lineTo(x + 1.2, y + 10.2);
          ctx.lineTo(x + 5.1, y + 1.2);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          continue;
        }

        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.ellipse(x, y, bodyW, bodyH, 0, 0, Math.PI * 2);
        ctx.fill();

        if (animal.type === "rabbit") {
          ctx.fillRect(x - 6, y - 14, 3, 8);
          ctx.fillRect(x + 3, y - 14, 3, 8);
        }

        if (animal.type === "fox") {
          // Long brush tail silhouette
          ctx.beginPath();
          ctx.moveTo(x - 10, y + 1);
          ctx.lineTo(x - 18, y - 2);
          ctx.lineTo(x - 13, y + 5);
          ctx.closePath();
          ctx.fill();
          // Small ear silhouettes
          ctx.beginPath();
          ctx.moveTo(x + 2, y - 5);
          ctx.lineTo(x + 5, y - 13);
          ctx.lineTo(x + 8, y - 5);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(x - 4, y - 5);
          ctx.lineTo(x - 1, y - 13);
          ctx.lineTo(x + 2, y - 5);
          ctx.closePath();
          ctx.fill();
        }

        if (animal.type === "deer") {
          // Antlers: connect to body, split to 2 then 4 upward branches.
          ctx.strokeStyle = body;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          // right trunk and two upper tines
          ctx.moveTo(x + 6, y - 3);
          ctx.lineTo(x + 10, y - 12);
          ctx.moveTo(x + 10, y - 12);
          ctx.lineTo(x + 13, y - 17);
          ctx.moveTo(x + 10, y - 12);
          ctx.lineTo(x + 9, y - 18);
          // left trunk and two upper tines
          ctx.moveTo(x + 4, y - 3);
          ctx.lineTo(x + 0, y - 12);
          ctx.moveTo(x + 0, y - 12);
          ctx.lineTo(x - 2, y - 17);
          ctx.moveTo(x + 0, y - 12);
          ctx.lineTo(x + 1, y - 18);
          ctx.stroke();
        }

        if (animal.type === "moose") {
          // Wider antler silhouette
          ctx.strokeStyle = body;
          ctx.lineWidth = 1.4;
          ctx.beginPath();
          ctx.moveTo(x + 9, y - 8);
          ctx.lineTo(x + 13, y - 14);
          ctx.lineTo(x + 16, y - 12);
          ctx.moveTo(x + 9, y - 8);
          ctx.lineTo(x + 6, y - 14);
          ctx.lineTo(x + 3, y - 12);
          ctx.stroke();
        }

        if (animal.type === "squirrel") {
          ctx.strokeStyle = body;
          ctx.lineWidth = 2.2;
          ctx.beginPath();
          ctx.arc(x - 7.4, y - 4.8, 4.8, Math.PI * 0.15, Math.PI * 1.5, true);
          ctx.stroke();
        }

        if (animal.type === "raccoon") {
          // Ringed tail silhouette
          ctx.fillStyle = body;
          ctx.beginPath();
          ctx.ellipse(x - 11, y + 1, 5.2, 2.2, -0.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(35, 38, 45, 0.75)";
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(x - 14, y);
          ctx.lineTo(x - 8, y);
          ctx.moveTo(x - 13, y + 1.8);
          ctx.lineTo(x - 9.2, y + 1.8);
          ctx.stroke();
        }

        if (animal.type === "owl") {
          ctx.fillStyle = body;
          // Side wing triangles on the vertical owl body.
          ctx.beginPath();
          ctx.moveTo(x - 2, y - 6);
          ctx.lineTo(x - 14, y);
          ctx.lineTo(x - 2, y + 6);
          ctx.closePath();
          ctx.moveTo(x + 2, y - 6);
          ctx.lineTo(x + 14, y);
          ctx.lineTo(x + 2, y + 6);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(x - 4, y - 8);
          ctx.lineTo(x - 2, y - 12);
          ctx.lineTo(x, y - 8);
          ctx.moveTo(x + 4, y - 8);
          ctx.lineTo(x + 2, y - 12);
          ctx.lineTo(x, y - 8);
          ctx.fill();
        }

        if (animal.type === "bear") {
          ctx.fillRect(x - 6, y + 5, 4, 4);
          ctx.fillRect(x + 2, y + 5, 4, 4);
        }

        if (animal.type === "moose") {
          ctx.fillRect(x - 6, y + 5, 3, 5);
          ctx.fillRect(x + 3, y + 5, 3, 5);
        }
        ctx.restore();
      }
    }

    function drawFireflies() {
      for (const firefly of state.fireflies) {
        const alpha = firefly.alpha ?? 1;
        if (alpha <= 0.01) continue;
        const glow = 0.45 + ((Math.sin(firefly.phase) + 1) * 0.5) * 0.55;

        ctx.fillStyle = "rgba(255, 244, 133, " + (glow * alpha).toFixed(3) + ")";
        ctx.beginPath();
        ctx.arc(firefly.x, firefly.y, 2.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "rgba(255, 244, 133, " + (glow * 0.28 * alpha).toFixed(3) + ")";
        ctx.beginPath();
        ctx.arc(firefly.x, firefly.y, 7.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawPlayer() {
      const p = state.player;
      drawShadowEllipse(p.x + 3, p.y + 16, 10, 4, 0.2);

      ctx.fillStyle = "#f1c892";
      ctx.beginPath();
      ctx.ellipse(p.x, p.y + 2, 10, 12, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(90, 60, 30, 0.55)";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = "#ffe4c7";
      ctx.beginPath();
      ctx.arc(p.x, p.y - 14, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "#c87a3b";
      ctx.beginPath();
      ctx.arc(p.x + 8, p.y + 2, 3.5, 0, Math.PI * 2);
      ctx.fill();

      if (state.waterCarried) {
        ctx.fillStyle = "rgba(90, 160, 215, 0.9)";
        ctx.beginPath();
        ctx.ellipse(p.x + 14, p.y - 18, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawNoAcornHint() {
      if (state.t >= state.noAcornHintUntil) return;

      const framesLeft = state.noAcornHintUntil - state.t;
      const life = clamp(framesLeft / 70, 0, 1);
      const rise = (1 - life) * 7;
      const pulse = 0.88 + Math.sin(state.t * 0.35) * 0.12;
      const y = state.player.y - 44 - rise;

      ctx.save();
      ctx.globalAlpha = 0.42 + life * 0.58;

      const drawAcornIcon = (x, size) => {
        ctx.fillStyle = "#7b4d25";
        ctx.beginPath();
        ctx.ellipse(x, y, size * 0.82, size, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#4d2b10";
        ctx.fillRect(x - size * 0.88, y - size * 0.96, size * 1.76, size * 0.44);
      };

      drawAcornIcon(state.player.x, 7.2 * pulse);

      ctx.fillStyle = "#ffe14f";
      ctx.font = "900 18px Trebuchet MS";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("!", state.player.x - 2, y - 3);
      ctx.textAlign = "start";
      ctx.textBaseline = "alphabetic";
      ctx.restore();
    }

    function drawHudOverlay() {
      const boxW = 360;
      const boxH = 38;
      const x = Math.round((canvas.width - boxW) / 2);
      const y = 10;
      ctx.save();
      ctx.fillStyle = "rgba(16, 56, 29, 0.75)";
      ctx.fillRect(x, y, boxW, boxH);
      ctx.fillStyle = "#f4fff0";
      ctx.font = "14px Trebuchet MS";
      ctx.textAlign = "start";
      ctx.textBaseline = "alphabetic";
      ctx.fillText("Eco Health: " + Math.round(state.ecoScore) + "% | Wildlife: " + getVisibleAnimals().length, x + 8, y + 25);
      ctx.restore();
    }

    function update() {
      playerMove();
      updateCamera();
      updateAcorns();
      updateLeaves();
      updateEcoSystem();
      updateTrashSpawns();
      updateAnimals();
      updateFireflies();
      updateSurprises();
      const cycle = getCycleInfo();
      if (
        state.hoverTarget &&
        state.hoverTarget.kind === "animal" &&
        ((cycle.isNight && !state.hoverTarget.ref.nightOnly) ||
          (!cycle.isNight && state.hoverTarget.ref.nightOnly))
      ) {
        clearCanvasHover();
      }
      checkWin();
      syncUI();
      updateDebugPanel();

      if (state.celebrationFrames > 0) state.celebrationFrames -= 1;
    }

    function render() {
      updateMessageReadability();
      const zoom = state.camera.zoom || 1;
      const camX = state.camera.x || 0;
      const camY = state.camera.y || 0;
      const daylight = getDaylightLevel();
      const nightAmount = 1 - daylight;
      const ecoBlend = getEcoBlend();
      const dayBase = [
        Math.round(PAPER.groundDay[0] + ecoBlend * 16),
        Math.round(PAPER.groundDay[1] + ecoBlend * 14),
        Math.round(PAPER.groundDay[2] + ecoBlend * 10)
      ];
      const nightBase = [
        Math.round(PAPER.groundNight[0] + ecoBlend * 6),
        Math.round(PAPER.groundNight[1] + ecoBlend * 8),
        Math.round(PAPER.groundNight[2] + ecoBlend * 5)
      ];
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      // Fill first so edge anti-aliasing never reveals underlying UI layers.
      ctx.fillStyle = mixColor(dayBase, nightBase, nightAmount);
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.setTransform(zoom, 0, 0, zoom, -camX * zoom, -camY * zoom);
      drawGround();
      drawStream();
      drawLeaves();
      drawAcorns();
      drawEcoDecorations();
      drawFlowers();
      drawGrassTufts();
      drawSpots();
      drawCampsiteItems();
      drawPlacementPreview();
      drawTreeCanopies();
      drawAnimals();
      drawFireflies();
      drawHoverHighlight();
      drawPlayer();
      drawNoAcornHint();
      ctx.restore();
      if (nightAmount > 0) {
        ctx.save();
        ctx.fillStyle = "rgba(8, 16, 12, " + (nightAmount * 0.22).toFixed(3) + ")";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }
      if (!isMobileViewport()) {
        drawHudOverlay();
      } else {
        drawMobileMiniMap();
      }
    }

    function frame() {
      state.t += 1;
      update();
      render();
      requestAnimationFrame(frame);
    }

    function initGame() {
      setTouchControlsEnabled(state.touchControlsEnabled);
      const loaded = loadSavedGame();
      if (!loaded) {
        resetGame();
        openStartOverlay();
      } else {
        syncNameInputs();
      }
      state.saveLoaded = true;
      setQuestPanelOpen(state.questPanelOpen);
      syncUI();
    }

    window.addEventListener("keydown", (e) => {
      const target = e.target;
      const typingTarget = Boolean(
        target &&
        (
          target.tagName === "INPUT" ||
          target.tagName === "TEXTAREA" ||
          target.tagName === "SELECT" ||
          target.isContentEditable
        )
      );
      const key = e.key.length === 1 ? e.key.toLowerCase() : e.key;
      if (typingTarget) {
        if (e.key === "Escape" && state.debugPanelOpen) {
          closeDebugPanel();
        }
        return;
      }
      if (
        state.inspectExpanded &&
        (e.key === "ArrowLeft" || e.key === "ArrowRight") &&
        state.notebookHistory.length > 1
      ) {
        e.preventDefault();
        flipNotebookHistory(e.key === "ArrowLeft" ? -1 : 1);
        return;
      }
      state.keys.add(key);
      if (e.key === "Escape" && state.debugPanelOpen) {
        closeDebugPanel();
      }
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(key)) {
        state.lastMovementInputFrame = state.t;
      }

      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
        e.preventDefault();
      }

      if (e.key === " ") {
        interact();
      }
    }, { passive: false });

    window.addEventListener("keyup", (e) => {
      const target = e.target;
      const typingTarget = Boolean(
        target &&
        (
          target.tagName === "INPUT" ||
          target.tagName === "TEXTAREA" ||
          target.tagName === "SELECT" ||
          target.isContentEditable
        )
      );
      if (typingTarget) return;
      const key = e.key.length === 1 ? e.key.toLowerCase() : e.key;
      state.keys.delete(key);
    });

    document.getElementById("newGame").addEventListener("click", () => {
      const ok = window.confirm("Start over and erase your saved forest?");
      if (!ok) return;
      localStorage.removeItem("forest-save");
      resetGame();
      state.saveLoaded = true;
      saveGameNow();
      openStartOverlay();
      setMenuOpen(false);
    });
    document.getElementById("debugOpen").addEventListener("click", openDebugPanel);
    ui.debugStartDay.addEventListener("click", forceDay);
    ui.debugStartNight.addEventListener("click", forceNight);
    ui.debugStream.addEventListener("click", () => {
      state.debugStreamOutline = !state.debugStreamOutline;
    });
    ui.debugEco.addEventListener("input", (event) => {
      const value = Number(event.target.value);
      state.ecoScore = clamp(value, 0, 100);
      ui.debugEcoValue.textContent = Math.round(state.ecoScore) + "%";
      syncUI();
    });
    document.getElementById("debugClose").addEventListener("click", closeDebugPanel);
    ui.questPopupClose.addEventListener("click", closeQuestPopup);
    ui.questToggle.addEventListener("click", () => {
      setQuestPanelOpen(!state.questPanelOpen);
    });
    ui.questWidgetToggle.addEventListener("click", () => {
      state.questWidgetExpanded = !state.questWidgetExpanded;
      renderQuestWidget();
    });
    ui.campsiteList.addEventListener("click", (event) => {
      const button = event.target.closest(".campsite-item");
      if (!button || button.disabled) return;
      const id = button.dataset.itemId;
      if (state.buildMode === id) {
        setBuildMode(null);
      } else {
        setBuildMode(id);
      }
      ui.buildMenu.hidden = true;
      ui.buildToggle.setAttribute("aria-expanded", "false");
    });
    ui.menuPlayerName.addEventListener("input", (event) => {
      setPlayerName(event.target.value);
    });
    ui.startPlayerName.addEventListener("input", (event) => {
      setPlayerName(event.target.value);
    });
    ui.startContinue.addEventListener("click", () => {
      setPlayerName(ui.startPlayerName.value);
      closeStartOverlay();
    });
    ui.menuToggle.addEventListener("click", () => {
      setMenuOpen(!state.menuOpen);
    });
    ui.notebookPanel.addEventListener("click", () => {
      if (state.inspectExpanded) return;
      state.inspectExpanded = true;
      ui.notebookPanel.classList.add("expanded");
      ui.notebookPanel.classList.remove("peek");
      ui.notebookPanel.classList.remove("collapsed");
      ui.notebookTab.setAttribute("aria-expanded", "true");
      ui.notebookTabArrow.textContent = "â–¾";
    });

    ui.notebookTab.addEventListener("click", (event) => {
      event.stopPropagation();
      const closeAllowed = Boolean(
        event.target.closest("#notebookTabLabel") ||
        event.target.closest("#notebookTabArrowHit") ||
        event.target.closest("#notebookTabArrow")
      );

      if (!state.inspectExpanded) {
        state.inspectExpanded = true;
        ui.notebookPanel.classList.add("expanded");
        ui.notebookPanel.classList.remove("peek");
        ui.notebookPanel.classList.remove("collapsed");
        ui.notebookTab.setAttribute("aria-expanded", "true");
        ui.notebookTabArrow.textContent = "â–¾";
        return;
      }

      if (!closeAllowed) return;
      state.inspectExpanded = false;
      ui.notebookPanel.classList.remove("expanded");
      ui.notebookPanel.classList.remove("peek");
      ui.notebookPanel.classList.add("collapsed");
      ui.notebookTab.setAttribute("aria-expanded", "false");
      ui.notebookTabArrow.textContent = "â–´";
    });
    ui.notebookTab.addEventListener("keydown", (event) => {
      if (event.key !== "Enter" && event.key !== " ") return;
      event.preventDefault();
      ui.notebookTab.click();
    });
    ui.notebookPrev.addEventListener("click", (event) => {
      event.stopPropagation();
      flipNotebookHistory(-1);
    });
    ui.notebookNext.addEventListener("click", (event) => {
      event.stopPropagation();
      flipNotebookHistory(1);
    });
    ui.menuClose.addEventListener("click", () => {
      setMenuOpen(false);
    });
    ui.inspectNameInput.addEventListener("input", (event) => {
      if (!state.inspectTarget) return;
      const wasNamed = Boolean(state.inspectTarget.customName && state.inspectTarget.customName.trim());
      const nextName = event.target.value.trim();
      state.inspectTarget.customName = nextName;
      if (
        state.inspectTarget.type &&
        !state.inspectTarget.everNamed &&
        !wasNamed &&
        nextName.length > 0
      ) {
        state.inspectTarget.everNamed = true;
        state.stats.animalsNamed += 1;
        logImpact("you watch " + nextName + " the " + state.inspectTarget.type + " closely");
      }
      if (unlockObservations(state.inspectTarget)) {
        renderInspectObservations();
      } else {
        ui.inspectObservationsBadge.hidden = !(state.t < state.notebookObsBadgeUntil);
      }
      scheduleSave();
    });
    ui.touchModeToggle.addEventListener("click", () => {
      setTouchControlsEnabled(!state.touchControlsEnabled);
    });
    ui.messageToggle.addEventListener("click", () => {
      const opening = ui.messageHistory.hidden;
      ui.messageHistory.hidden = !opening;
      ui.messageToggle.textContent = opening ? "â–´" : "â–¾";
      ui.messageToggle.setAttribute("aria-expanded", opening ? "true" : "false");
    });
    ui.buildToggle.addEventListener("click", () => {
      const opening = ui.buildMenu.hidden;
      ui.buildMenu.hidden = !opening;
      ui.buildToggle.setAttribute("aria-expanded", opening ? "true" : "false");
    });
    ui.debugOverlay.addEventListener("click", (e) => {
      if (e.target === ui.debugOverlay) closeDebugPanel();
    });
    ui.questPopup.addEventListener("click", (e) => {
      if (e.target === ui.questPopup) closeQuestPopup();
    });
    canvas.addEventListener("click", handleCanvasClick);
    canvas.addEventListener("mousemove", handleCanvasMove);
    canvas.addEventListener("pointerdown", (event) => {
      if (event.pointerType === "mouse") return;
      if (!state.touchControlsEnabled) return;
      const point = getCanvasPoint(event);
      state.mouseWorld = point;
      handleCanvasPoint(point);
      event.preventDefault();
    }, { passive: false });
    canvas.addEventListener("mouseleave", clearCanvasHover);
    window.addEventListener("resize", () => {
      updateCamera();
    });
    document.addEventListener("pointerdown", (event) => {
      if (ui.buildMenu.hidden) return;
      const target = event.target;
      if (target.closest("#buildMenu") || target.closest("#buildToggle")) return;
      ui.buildMenu.hidden = true;
      ui.buildToggle.setAttribute("aria-expanded", "false");
    });
    document.addEventListener("pointerdown", (event) => {
      if (!state.menuOpen) return;
      const target = event.target;
      if (target === ui.gameMenu) {
        setMenuOpen(false);
        return;
      }
      if (target.closest(".menu-sheet") || target.closest("#menuToggle")) return;
      setMenuOpen(false);
    });

    ui.best.textContent = state.bestScore;
    setupMobileControls();
    updateCamera();
    initGame();
    frame();
  </script>
</body>
</html>
